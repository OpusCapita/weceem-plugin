<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
    <head>
        <title>Weceem Documentation 1.3-SNAPSHOT</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen, print" title="Style" charset="utf-8" />
        <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8" />
    <script type="text/javascript">
function addJsClass(el) {
    var classes = document.body.className.split(" ");
    classes.push("js");
    document.body.className = classes.join(" ");
}
    </script>
    </head>

    <body class="body" onload="addJsClass();">
        <div id="navigation">
            <ul>
                <li>
                    <div id="nav-summary" onmouseover="toggleNavSummary(false)" onmouseout="toggleNavSummary(true)">
                        <a href="../guide/index.html" class="button">Table of contents</a>
                        <div id="nav-summary-childs" style="display:none;">
                            
                            <div class="toc-item" style="margin-left:0"><a href="#1.Introduction"><strong>1</strong><span>Introduction</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#2.ConfigurationAndInstallation"><strong>2</strong><span>Configuration and installation</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#3.GeneralBehaviourAndConcepts"><strong>3</strong><span>General behaviour and concepts</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#4.UsersGuide"><strong>4</strong><span>User Guide</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#5.WeceemSecuritPolicy"><strong>5</strong><span>Weceem security policy</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#customization"><strong>6</strong><span>Developer Guide</span></a></div>
                            
                        </div>
                    </div>
                </li>
                <li class="separator selected">
                    <a id="ref-button" onclick="localToggle(); return false;" href="#">Quick Reference</a>
                </li>
            </ul>
        </div>
        <div id="header">
            <div class="images clearfix">
                
                
            </div>
            <p>jCatalog Software AG</p>
        </div>


        <table id="colset" border="0" cellpadding="0" cellspacing="0">
            <tr>
                <td id="col1">
                    <div id="main" class="corner-all">

                        <span id='toggle-col1' class="toggle">(<a href="#" onclick="localToggle(); return false;">Quick Reference</a>)</span>

                        <div class="project">
                            <h1>Weceem Documentation - Reference Documentation</h1>
                            <p><strong>Authors:</strong> Stephan Albers, Mark Palmer, July Antonicheva</p>
                            <p><strong>Version:</strong> 1.3-SNAPSHOT</p>
                            
                        </div>

                        
                        <div id="table-of-content">
                            <h2>Table of Contents</h2>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#1.Introduction"><strong>1</strong><span>Introduction</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#2.ConfigurationAndInstallation"><strong>2</strong><span>Configuration and installation</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#3.GeneralBehaviourAndConcepts"><strong>3</strong><span>General behaviour and concepts</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#4.UsersGuide"><strong>4</strong><span>User Guide</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#0.adminUI"><strong>4.1</strong><span>Administrative UI</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#1.CreateSpace"><strong>4.2</strong><span>Create Space</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#2.SynchronizeFiles"><strong>4.3</strong><span>File Synchronization</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#3.Plugins"><strong>4.4</strong><span>Plugins</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#4.Licenses"><strong>4.5</strong><span>Licenses</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#5.CheckLinks"><strong>4.6</strong><span>Check Links</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#6.Users"><strong>4.7</strong><span>CMS User management</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#7.CreateHtml"><strong>4.8</strong><span>Create HTML pages</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#8.CreateBlogComment"><strong>4.9</strong><span>Create Blog, Blog Entries and Comments</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#9.CreateServerFolderFile"><strong>4.10</strong><span>Server Directory and Server File</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#10.CreateTemplateWidget"><strong>4.11</strong><span>Templates and Widgets</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#11.CreateAction"><strong>4.12</strong><span>Create Action</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#12.CreateBinaryContent"><strong>4.13</strong><span>Create Binary Content</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#13.CreateCssJs"><strong>4.14</strong><span>Create CSS Stylesheets and Javascript Sources</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#14.CreateExternalLink"><strong>4.15</strong><span>Create External Link</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#15.CreateGroovyScript"><strong>4.16</strong><span>Create Groovy Script</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#16.CreateFolder"><strong>4.17</strong><span>Create Folder</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#17.CreateWikiPage"><strong>4.18</strong><span>Create Wiki page</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#18.CreateVirtualContent"><strong>4.19</strong><span>Create Virtual Content</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#19.StatusPublishing"><strong>4.20</strong><span>Statuses, Publishing and Unpublishing by date</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#20.Search"><strong>4.21</strong><span>Search in Weceem</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#21.DragAndDrop"><strong>4.22</strong><span>Operations with content repository tree</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#22.TagsAndJspContent"><strong>4.23</strong><span>Tags and JSP content</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#23.ReusingCodeWithWidgets"><strong>4.24</strong><span>Reusing code and page fragments with Widgets</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#24.UsingImagesInHtml"><strong>4.25</strong><span>Using images in HTML content</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#25.UploadingAndLinking"><strong>4.26</strong><span>Uploading and linking to files</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#26.ControllingAccess"><strong>4.27</strong><span>Controlling who can see content and when</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#27.MultiLanguageSite"><strong>4.28</strong><span>Creating sites with content in different languages</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#28.PerformanceAndCache"><strong>4.29</strong><span>Site performance and caching content</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#29.PublishingFeeds"><strong>4.30</strong><span>Publishing Feeds</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#5.WeceemSecuritPolicy"><strong>5</strong><span>Weceem security policy</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#customization"><strong>6</strong><span>Developer Guide</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#0.HookingIntoTheAdminInterface"><strong>6.1</strong><span>Hooking into the Admin interface</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#1.CreateCustomContentTypes"><strong>6.2</strong><span>Create custom content types</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#2.CustomContentEditors"><strong>6.3</strong><span>Custom content editors</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#3.CustomRequestAndFormSubmissionWithGroovyScripts"><strong>6.4</strong><span>Custom request/form submission with groovy scripts</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#4.EmbeddingContent"><strong>6.5</strong><span>Embedding content</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#5.ExportingAndImportingContent"><strong>6.6</strong><span>Exporting and importing content</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#6.HookingIntoContentEvents"><strong>6.7</strong><span>Hooking into content events</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#7.PageRendering"><strong>6.8</strong><span>Page rendering</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#8.IntegratingTheAuthenticationAndAuthorisationSystem"><strong>6.9</strong><span>Integrating the  authentication and authorisation system</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#9.StylingWithTemplates"><strong>6.10</strong><span>Styling With Templates</span></a></div>
                            
                            <div style="clear:both" ></div>
                        </div>
                        
                        

<h1 id="1.Introduction">1 Introduction</h1>
<h3> Weceem CMS Grails Plugin</h3><p class="paragraph"/>Weceem is an open source Content Management System. It is written in Groovy and Grails and leverages the Grails
infrastructure to a build customized CMS inside the Grails application.<p class="paragraph"/>It can be used to manage content, and create desired content types for custom functionality which can be integrated
with existing systems.<p class="paragraph"/>With the Weceem plugin you can host corporate websites, simple blogs, search the site, SEO or build your own
applications. You can define your own content types that add custom functionality or integrate tightly with existing
systems you have.<p class="paragraph"/>There are numerous customization points that allow you to tailor the security mechanisms, administration skin, URL
paths, scope for custom data types and server-side scripting using Groovy. It is built from the ground up to be
embeddable as well as a standalone application.<p class="paragraph"/>The plugin supports multiple content repositories. Each repository is called a "Space" and represents a website that
you maintain.<p class="paragraph"/><strong class="bold">Spaces</strong> are used to map and track content exchanges. They can have multiple access rights defined in the Weceem
security policy, hence one user can have permission or rights for different spaces.<p class="paragraph"/><strong class="bold">Content</strong> is created for the visitors of your website. Different types of content can be created and arranged in any
desired structure within a Space<p class="paragraph"/>All you need for Weceem is an SQL database for storing content, a Java servlet container like Tomcat or Jetty to run.<p class="paragraph"/>Weceem's content is stored in a SQL database and not in files on the server filesystem. Uploaded file content is stored
on the server filesystem and information about the file stored in the SQL database.<p class="paragraph"/>Current version of Weceem plugin (Weceem-1.2) is compatible with Grails 2.3<p class="paragraph"/><strong class="bold">Feature Highlights</strong>
<ul class="star">
<li>WYSIWYG Editor</li>
<li>Hierarchical content repository</li>
<li>Blogs</li>
<li>Full-text search</li>
<li>Form submissions</li>
<li>Templates with inheritance</li>
<li>Reusable widgets</li>
<li>Multiple-language support</li>
<li>Tagging</li>
<li>Auto-publish and auto-unpublish by date</li>
<li>Spaces: manage many sites in a single Weceem instance with per-space permissions</li>
<li>Content types include: HTML, Folder, JavaScript, CSS, Files, Blog, Comment, External Link, Virtual Content, Wiki Pages, Groovy Scripts and Actions</li>
<li>Extensible using Java, Groovy and Grails</li>
<li>No design or SEO restrictions</li>
</ul><p class="paragraph"/>


<h1 id="2.ConfigurationAndInstallation">2 Configuration and installation</h1>
<h3> Installation</h3><p class="paragraph"/>Weceem is available either as a standalone Java web application (.war file) for deployment to standard Java server environments, or as a plugin for the <a href="http://grails.org/" target="blank">Grails application framework</a>.<p class="paragraph"/><h4> Requirements</h4><p class="paragraph"/>Deploying Weceem CMS requires:
<ul class="star">
<li> Java 6 or higher</li>
<li> A supported SQL server e.g. MySQL or Postgres</li>
<li> A recommended 500MB RAM allocated to the Java VM</li>
<li> A writable filesystem folder for storing Lucene full-text search indexes</li>
</ul><p class="paragraph"/>You don't need to install or have any understanding of Grails to use Weceem, but if you want to develop a custom application that uses Weceem, you will also need to install Grails.<p class="paragraph"/><h4>Upgrading all Weceem installations</h4><p class="paragraph"/>Prior to installing a new version of Weceem, always export each of your spaces to ensure you have a backup. Additionally, ensure your database and uploaded files (e.g. WeceemFiles/) folder are backed up.<p class="paragraph"/><h4>Installing Weceem Plugin into the application</h4><p class="paragraph"/>To install the Weceem plugin, the dependency must be added into grails-app/conf/BuildConfig.groovy file in Grails application.
<div class="code"><pre>compile ':weceem:1.3&#45;SNAPSHOT'</pre></div><p class="paragraph"/>The plugin should function with Grails versions 2.1 and higher.<p class="paragraph"/>Once the plugin is installed into the application, a few Grails configuration changes may be required to make the CMS work in your application. These options are required for Weceem to operate correctly inside the application.<p class="paragraph"/><strong class="bold">Note:</strong> When upgrading from an earlier version of the Weceem plugin, you may need to manually uninstall some older Grails plugins, if your new release of Grails does not do it automatically.<p class="paragraph"/><strong class="bold">Warning!</strong> Weceem plugin uses Searchable plugin (version 0.6.6 or higher), it requires additional maven repository  <em class="italic">"http://repo.grails.org/grails/core"</em>  for getting
dependencies. Do not forget to configure:<p class="paragraph"/><div class="code"><pre>repositories &#123;
             &#8230;
             mavenRepo <span class="java&#45;quote">"http://repo.grails.org/grails/core"</span><p class="paragraph"/>         &#125;</pre></div><p class="paragraph"/><h3> Configuration</h3><p class="paragraph"/>Once the plugin is installed, there may be some Grails configurations that need to be changed to make the CMS work in the application. These options are required for Weceem to operate correctly within the application.<p class="paragraph"/>Configuration of Weceem is primarily through Grails configuration settings. In Weceem application these will come from a properties file that could be configured via system property
<div class="code"><pre>weceem.config.location</pre></div>
specified in the command line. But in the custom Grails application configuration is typically loaded from Config.groovy.<p class="paragraph"/>If you use a <strong class="bold">weceem.war</strong> that is built from GitHub and don't define <strong class="bold">weceem.config.location</strong> path, pay attention that
the application will look for <strong class="bold">weceem.properties</strong> file from server root, for example for the Tomcat Server the
properties file should be at <strong class="bold">/tomcat-server/webapps/weceem.properties</strong><p class="paragraph"/>There are also several configuration options that allow you to customize how it behaves and looks.<p class="paragraph"/><h4> Allowing file extensions</h4><p class="paragraph"/>By default, Grails applications have content negotiation enabled based on file extensions in the URI, and this file extension is then removed from the URI. For the CMS to function correctly with content URIs like "common.css" and "jquery.js", you need to turn this off. To do so, change your application's Config.groovy to :<p class="paragraph"/><div class="code"><pre>grails.mime.file.extensions = <span class="java&#45;keyword">false</span></pre></div><p class="paragraph"/><h4> Default codec usage</h4><p class="paragraph"/>By default, Grails applications are configured to use value 'html' - legacy setting for codec used to encode data with ${} . But Weceem plugin requires such data without encoding.<p class="paragraph"/><div class="code"><pre>grails.views.<span class="java&#45;keyword">default</span>.codec=<span class="java&#45;quote">"none"</span></pre></div><p class="paragraph"/><h4>Be attentive with Resources plugin!</h4><p class="paragraph"/>Uninstall the `Resources` plugin or keep it but set<p class="paragraph"/><div class="code"><pre>grails.resources.adhoc.excludes=&#91;'/plugins/weceem&#45;1.3&#45;SNAPSHOT'&#93;</pre></div><p class="paragraph"/>It is necessary to exclude everything served by Weceem (see above note on setting a content URL prefix) because Weceem must serve this content and Resources assumes that `/css` and so on are static resources.<p class="paragraph"/><h4> URL mappings and Weceem</h4><p class="paragraph"/>To replicate the behaviour of the binary Weceem Application WAR that can serve content from the "/" URI of your application, you must ensure the default URL Grails mapping for "/" in your application is removed. You will also probably benefit from removing the generic "$controller/$action?/$id?" mapping which can cause confusion.<p class="paragraph"/>You can namespace all Weceem controllers using configuration options to prefix all URIs that Weceem uses.<p class="paragraph"/><h4>Setting URL prefix for all content served by Weceem</h4><p class="paragraph"/>Weceem by default maps all created content into the "root" URI of the application. URLs are formed by "/{space URI alias}/${document URI alias path....}". Having a space with a blank alias URI, allows you to map content into the root URI.  To achieve this Weceem has to be rather promiscuous with its URI mapping.<p class="paragraph"/>If you would like your own controllers to be accessible with your own Grails URL mappings, you can prefix all content URIs by setting a single Config.groovy setting:<p class="paragraph"/><div class="code"><pre>weceem.content.prefix = 'content'</pre></div><p class="paragraph"/>With this, all Weceem content will be accessed under "/content/" - i.e.  http://localhost:8080/content/About<p class="paragraph"/><h4>Setting URL prefix for non-content Weceem controllers</h4><p class="paragraph"/>Weceem has its own non-content controllers that provide publicly-accessible support functionality such as the search, archive and visitor content submission controllers. If there are name conflicts with your own controllers, prefix these URIs with the following Config.groovy setting:<p class="paragraph"/><div class="code"><pre>weceem.tools.prefix = 'wcm&#45;tools'</pre></div><p class="paragraph"/>This will then ensure that all the Weceem tool controllers are accessed like this <code>http://localhost:8080/wcm-tools/search</code><p class="paragraph"/><h4>Setting URL prefix for Weceem administration UI</h4><p class="paragraph"/>The Weceem repository and administration UIs may also clash with your URI conventions, or you may have your own "admin" controller that you want at "/admin". For this, you can just change the prefix for the Weceem Admin controllers by adding the following to Config.groovy:<p class="paragraph"/><div class="code"><pre>weceem.admin.prefix = 'wcm&#45;admin'</pre></div><p class="paragraph"/>The standard Weceem admin interfaces under http://localhost:8080/wcm-admin/<p class="paragraph"/><h4> Defining available default Space templates</h4><p class="paragraph"/>You must tell Weceem what default content spaces are available to users or your code. There are two default spaces provided by the plugin but usually your application will want to specify alternative defaults so that it "boots" with your own content in it.<p class="paragraph"/><h4> Setting the location of uploaded files</h4><p class="paragraph"/>Weceem, by default, will store files uploaded by you (e.g. images, CSS and so on) to a folder inside the application's folder on the server. However, during an application upgrade, this becomes inconvenient because the files will often need to be manually duplicated in the new location on the server.<p class="paragraph"/>Since 1.0-M1 you can set the location of the upload folder or URL:<p class="paragraph"/><div class="code"><pre>// Tell weceem to use a specific path /<span class="java&#45;keyword">var</span>/weceem/uploads
/<span class="java&#45;keyword">var</span>/weceem/uploads weceem.upload.dir = 'file:///<span class="java&#45;keyword">var</span>/weceem/uploads'<p class="paragraph"/>// or tell weceem to keep it in the application folder, but with a <span class="java&#45;keyword">new</span> URL
weceem.upload.dir = '/weceem_uploads/'</pre></div><p class="paragraph"/>Weceem auto-senses file URLs in the value and uses that location if it is a file URL. If it is not a file URL, then it assumes it is a new URL path and uses it when serving the files.<p class="paragraph"/>Weceem will still store the files in <code>&#60;app-dir&#62;/WeceemFiles</code>, if a value is not specified for this config variable. These will be served from <code>http://&#60;yourhost&#62;/&#60;yourapppath&#62;/uploads/</code><p class="paragraph"/><h4>Customizing user profile and logout</h4><p class="paragraph"/>When integrating your own user authentication/authorization system, you will want the Profile and Log Out links in Weceem admin to point to the relevant functions in your application.  Specify a map of arguments that will be passed to the Grails <strong class="bold">g:link</strong> tag to create the links for these functions, with the following Config.groovy settings:<p class="paragraph"/><div class="code"><pre>weceem.profile.url = &#91;controller:'register', action:'edit'&#93; weceem.logout.url = &#91;controller:'logout'&#93;</pre></div><p class="paragraph"/>Controller/action etc can be anything you like. You could use any arguments accepted by the Grails linking tags here e.g: uri, url, params, mapping and so on.<p class="paragraph"/><h4>Customizing the look and feel of Weceem Admin</h4><p class="paragraph"/>For the Weceem Admin pages to fit in better with your application's own styling, you can specify a different layout GSP for it with this Config option:<p class="paragraph"/><div class="code"><pre>weceem.admin.layout=<span class="java&#45;quote">"mylayout"</span></pre></div><p class="paragraph"/>This stops Weceem from using the standard "weceemadmin" GSP layout and uses yours instead.<p class="paragraph"/><h4>Customizing page for 404 and 406 Server responses</h4><p class="paragraph"/>For the HTTP 404 and HTTP 406 Server responses, you can specify a different GSP pages with this Config option:<p class="paragraph"/><div class="code"><pre>weceem.page404 = 'errorpage404'
       weceem.page406 = 'errorpage406'</pre></div><p class="paragraph"/>By default, the pages '404.gsp' and '406.gsp' from Weceem plugin are used.<p class="paragraph"/><h4>Controlling creation of the default space</h4><p class="paragraph"/>You can configure whether or not Weceem should create a default space at startup, as well as what templates are available to the user:<p class="paragraph"/><div class="code"><pre>// Turn off <span class="java&#45;keyword">default</span> space creation <span class="java&#45;keyword">if</span> no spaces found at startup
weceem.create.<span class="java&#45;keyword">default</span>.space = <span class="java&#45;keyword">false</span><p class="paragraph"/>// Set the file: or classpath: URL of the <span class="java&#45;keyword">default</span> space zip <span class="java&#45;keyword">if</span> <span class="java&#45;keyword">default</span> creation is ON
weceem.<span class="java&#45;keyword">default</span>.space.template = <span class="java&#45;quote">"file:/path/to/template.zip"</span></pre></div><p class="paragraph"/><h4>Changing the list of space templates available to users</h4><p class="paragraph"/>To change the list of space templates available to users when they create a new space, list them in your Config:<p class="paragraph"/><div class="code"><pre>// Set the list of available space templates when a user creates a <span class="java&#45;keyword">new</span> space
weceem.space.templates = &#91;
    <span class="java&#45;keyword">default</span>: <span class="java&#45;quote">"classpath:/org/weceem/resources/<span class="java&#45;keyword">default</span>&#45;space&#45;template.zip"</span>,
    basic:<span class="java&#45;quote">"classpath:/org/weceem/resources/basic&#45;space&#45;template.zip"</span>&#93;</pre></div><p class="paragraph"/>Space templates are regular Weceem export ZIPs, and can reside in the file system (file:) or classpath (classpath:)<p class="paragraph"/>Use this to hide the default Weceem spaces and restrict user access to the space templates. This list of space templates does not have to include the default space template, hence you can have a default initial space that is unavailable to the users.



<h1 id="3.GeneralBehaviourAndConcepts">3 General behaviour and concepts</h1>
<h3> Content Publishing Workflow</h3><p class="paragraph"/>A simple workflow mechanism is implemented in Weceem.<p class="paragraph"/>In Weceem, the workflow hinges on the Status of each content node. The following Status options are provided:
<ul class="star">
<li>Draft</li>
<li>Unmoderated</li>
<li>Reviewed</li>
<li>Approved</li>
<li>Published</li>
<li>Archived</li>
</ul><p class="paragraph"/>There is no UI for editing the list of statuses, but if you are a developer and wish to add new ones, bear in mind the rules for the workflow as set out here.<p class="paragraph"/>Each status has a numerical code - e.g. Draft is 100, Unmoderated - 150, Published - 400 etc. Each status also has a flag to indicate whether or not it is "public" content i.e. can be viewed by non-administrators. By default Published is the only status with this flag set.<p class="paragraph"/>All changes to status are made manually by repository users, unless the <strong class="bold">Publish From</strong> or <strong class="bold">Publish Until</strong> fields have values,<p class="paragraph"/>In the case of <strong class="bold">Publish From</strong>, once the date passes, the status of the content will change to the first status with "public content" flag switched on, which has a higher code number than the current status of the content. This offers scope for other statuses beyond the existing set, and migration upward through those states.<p class="paragraph"/>The one caveat here is that the <strong class="bold">Publish From</strong> mechanism will never change the status on content that is currently in the "Unmoderated" or "Archived" status used for visitor-submitted or expired content. If you need to change which status is used for "Unmoderated" or "Archived" content you can do this by setting the configuration variables to the numerical code values of the desired status <code>weceem.unmoderated.status</code> and <code>weceem.archived.status</code><p class="paragraph"/>With <strong class="bold">Publish Until</strong>, the status of any published content that has expired will be set to the "Archived" status or the status defined in the configuration variable <code>weceem.archived.status</code><p class="paragraph"/><h4> Page Variables</h4><p class="paragraph"/>Templates, Widgets and HTML Content (with allow GSP enabled) have access to a data model that includes several variables used to render information about the current page, user or space.<p class="paragraph"/><strong class="bold">Variable: page</strong><p class="paragraph"/>This object presents information about the current page of the web site. The page is constructed from a template and content, and is located using a unique URI.  This is not to be confused with the "active" content node.<p class="paragraph"/><strong class="bold">Properties</strong><p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Name</strong></th><th>Description</th></tr><tr class="table-odd"><td>URI</td><td>uri of this page relative to the current space</td></tr><tr class="table-even"><td>parentURI</td><td>uri of this page's content node's parent</td></tr><tr class="table-odd"><td>lineage</td><td>list of ancestor nodes, in top-down order</td></tr><tr class="table-even"><td>title</td><td>page title</td></tr><tr class="table-odd"><td>titleForHTML</td><td>page title for HTML title tag, including SEO keywords</td></tr><tr class="table-even"><td>titleForMenu</td><td>page title for rendering menus, usually a shorter version of the title</td></tr></table><p class="paragraph"/><strong class="bold">Variable: user</strong><p class="paragraph"/>This object presents information about the current user.<p class="paragraph"/><strong class="bold">Properties</strong><p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Name</strong></th><th><strong class="bold">Description</strong></th></tr><tr class="table-odd"><td>username</td><td>User's login name</td></tr><tr class="table-even"><td>firstName</td><td>User's first name</td></tr><tr class="table-odd"><td>lastName</td><td>User's last name</td></tr><tr class="table-even"><td>email</td><td>User's email address</td></tr></table><p class="paragraph"/><strong class="bold">Variable: node</strong><p class="paragraph"/>This object provides access to information about the primary content node of this page. The properties available will vary based on the content type.<p class="paragraph"/><strong class="bold">Properties</strong><p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Name</strong></th><th><strong class="bold">Description</strong></th></tr><tr class="table-odd"><td>title</td><td>content title</td></tr><tr class="table-even"><td>content</td><td>content text</td></tr><tr class="table-odd"><td>aliasURI</td><td>primary URI for this content node</td></tr><tr class="table-even"><td>language</td><td>language of this content, a Language object</td></tr><tr class="table-odd"><td>createdBy</td><td>name of the user who created the content</td></tr><tr class="table-even"><td>createdOn</td><td>date the content was originally created</td></tr><tr class="table-odd"><td>changedBy</td><td>username of the last user to edit the content</td></tr><tr class="table-even"><td>changedOn</td><td>date on which the content was last edited</td></tr><tr class="table-odd"><td>space</td><td>space (object) to which this content node belongs</td></tr></table><p class="paragraph"/>


<h1 id="4.UsersGuide">4 User Guide</h1>



<h2 id="0.adminUI">4.1 Administrative UI</h2>
To edit or create content, view the content repository or perform any administrative functions you must first log in to
Weceem.<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/login.jpg"></img><p class="paragraph"/>You can do this by browsing to &#60;yourserver-url&#62;/admin if you are using the standalone Weceem WAR. Here you will be
prompted for your user name and password. By default new installations have a single "admin" account with password
"admin". You must change this password, and you can do so in the Administration section.
Logging in to your own application that uses Weceem plugin<p class="paragraph"/>Normally this will be a case of browsing to &#60;yourserver-url&#62;/admin but your application may have configured weceem to
use a different URL mappings such as /wcm/admin. You need to look at your application's configuration if /admin does not
work for you.<p class="paragraph"/>Weceem contains administrative UI for users that have access to creating new content and managing existed sources.
In your weceem.properties file or in Config.groovy file the user can customize URL that leads to admin UI. By default
the mapping <strong class="bold">"wcm/admin"</strong> will be used.<p class="paragraph"/>Admin UI consists of two tabs: "Content" and "Administration".<p class="paragraph"/><strong class="bold">Content tab</strong><p class="paragraph"/>The content repository is the main user interface for Weceem.<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/contentAdminUI.jpg"></img><p class="paragraph"/>What you see in the repository is the tree of content for the currently selected space. You can switch spaces using the
space selector box.<p class="paragraph"/>Each row in the table represents one of your content nodes. You can do the following things with rows:
<ul class="star">
<li>To select a node, you click its row (but not the icon).</li>
<li>To drag a node to a new location in the tree, you drag the content's icon</li>
<li>To edit the content you click the title of the content</li>
</ul><p class="paragraph"/>With a row selected, it will be highlighted and when you click the "New Content" or "More Actions" button the operation
will be performed on the selected node. So when a node is selected and you choose "New Content", the new content will be
a child of the node you selected in the repository.<p class="paragraph"/>To deselect a row - so that you can create new content at the root of the repository - you just click the row again.<p class="paragraph"/>You can also search for content using the search box. The results can be further filtered by content type and date, and
sorted by clicking the column headers.<p class="paragraph"/><p class="paragraph"/>
<strong class="bold">Administration tab</strong><p class="paragraph"/>The tab contains several editors:
<ul class="star">
<li>Spaces</li>
<li>Synchronize files</li>
<li>Plugins management</li>
<li>Licenses</li>
<li>Check links</li>
<li>Users</li>
</ul><p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/administrationAdminUI.jpg"></img><p class="paragraph"/>



<h2 id="1.CreateSpace">4.2 Create Space</h2>
Weceem supports multiple content repositories. Each repository is called a "Space" and represents a website that you
maintain.<p class="paragraph"/><strong class="bold">About spaces</strong><p class="paragraph"/>A Space contains "Content" that is served to your visitors. There are many different types of Content that you can
create and arrange in any structure you like within your Space. You can have as many spaces as you like, representing
different sites or micro sites.<p class="paragraph"/>Spaces are separate content graphs and are imported and exported separately for backup purposes and have a URI alias
that defines the web address of that space within your server. You cannot normally use content from one space inside
another.<p class="paragraph"/>Spaces can have different access rights defined in the Weceem security policy, so the same user may have different
permissions in different spaces.<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/spaceEditor.jpg"></img><p class="paragraph"/>Each Space is determined by its name and alias URI, where alias URI is a prefix for your site (Space), that will be used
in URL mappings when you try to review the ready site content.<p class="paragraph"/>


<h2 id="2.SynchronizeFiles">4.3 File Synchronization</h2>
Synchronizing a space with the server filesystem will create new content nodes for any directories and files that exist
in the filesystem but are not currently in the content repository.<p class="paragraph"/>You will be given the option to delete any content nodes that refer to server files or directories that no longer exist.<p class="paragraph"/>



<h2 id="3.Plugins">4.4 Plugins</h2>
The feature you selected is not quite ready. Please view the Weceem.org roadmap for what is coming in the next release.<p class="paragraph"/>


<h2 id="4.Licenses">4.5 Licenses</h2>
Weceem is 100% open source licensed.
The Weceem application and plugin and Grails are Apache 2 licensed
The jQuery and jQuery UI libraries are provided under the MIT license.<p class="paragraph"/>


<h2 id="5.CheckLinks">4.6 Check Links</h2>
The feature you selected is not quite ready. Please view the Weceem.org roadmap for what is coming in the next release.<p class="paragraph"/>


<h2 id="6.Users">4.7 CMS User management</h2>
To create, edit or manage the content repository, users must be able to log in to the CMS.<p class="paragraph"/>When using the Weceem Application, a simple user management system is provided.<p class="paragraph"/>To access this, log in as administrator and go to the Administration section and then select Users. From there you can
create and edit users.<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/users.jpg"></img><p class="paragraph"/>


<h2 id="7.CreateHtml">4.8 Create HTML pages</h2>
<strong class="bold">About content</strong><p class="paragraph"/>Content is ultimately what your end-users view on your site. Weceem has an extensible content system, and supplied
content types for the most common web content.<p class="paragraph"/>The following content types are supplied out of the box:
<ul class="star">
<li>Action - A server-side action that will execute the code in a Groovy Script node, for example to create new content</li>
</ul><p class="paragraph"/>nodes or send an email
<ul class="star">
<li>Blog - The root node of a Blog, which has Blog Entry nodes as children</li>
<li>Blog Entry - An entry (child of) a Blog node</li>
<li>Comment - A comment on a content node. Any nodes can have comments attached or created.</li>
<li>External Link - A URL of another website. When this URI is rendered, it redirects to the external site</li>
<li>Folder - A folder for grouping together content nodes and creating URI hierarchy</li>
<li>Groovy Script - A piece of Groovy code to execute on the server, used by Action nodes</li>
<li>HTML - A piece of HTML which may contain GSP (Grails Server Page) tags</li>
<li>JavaScript - A piece of JavaScript source</li>
<li>Server File - A file uploaded to the Weceem repository and stored on the server filesystem, e.g. an image file</li>
<li>Server Directory - A directory on the server filesystem which contains Server File nodes</li>
<li>Stylesheet - A CSS style sheet</li>
<li>Template - A GSP template used to layout and decorate the current content node</li>
<li>Widget - A reusable GSP fragment for rendering sections of a page, e.g. a header/footer or a remote news feed.</li>
</ul><p class="paragraph"/>The Template, Widget and HTML content nodes can use Weceem tags and other Grails tags to perform view rendering logic.
Weceem's content is stored in an SQL database, not in files on the server filesystem. The exception to this rule is
uploaded file content, which is stored "as is" in the server filesystem, with information about the files stored in the
SQL database.<p class="paragraph"/>When editing content, you are shown only the fields appropriate to that type of content. For example when editing
JavaScript or CSS you see a code editor, but when editing HTML content you see a rich text editor.<p class="paragraph"/>Developers writing their own Grails application that embeds Weceem can easily add their own new content types that have
a great deal of flexibility allowing them to customize their behaviour in the editor and when rendered.<p class="paragraph"/>When creating new content the currently selected repository node will become the parent. You will be asked what kind of
content you wish to create, and then be shown the content editor for that content type.<p class="paragraph"/>Different content types have different fields and capabilities, and the editor adapts accordingly. Most content types
will have at least a Title and Status, an area for the main content, and the Extras, Metadata, Change history and
Parents &#38; Children sections.<p class="paragraph"/>In the editor you can <strong class="bold">Save</strong> and return to the repository or save and continue to keep your changes but carry on
editing. You can also <strong class="bold">Preview</strong> your changes in a new window without saving them, if the content is able to be rendered
in isolation (e.g. Templates and Widgets cannot themselves be previewed).<p class="paragraph"/>The HTML editor will present itself as a rich text editor unless you have saved it with "Allow GSP", in which case it
will show as a code editor. Style sheets, Javascript, Templates, Widgets and Groovy code all present with a syntax
highlighting code editor.<p class="paragraph"/><strong class="bold">Create HTML page</strong><p class="paragraph"/>If the user needs to create HTML page, he needs to select row in the content repository tree by clicking on it. As the
result the row is preselected by color. The row selection means that the content will be child to selected content. Then
at the top of <strong class="bold">Content</strong> tab there is a button <strong class="bold">New Content</strong> that offers a list of available content types to be created.
Select the type "HTML" and press "Create" button. The new content editor
should be shown to the user<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/htmlEditor.jpg"></img><p class="paragraph"/><p class="paragraph"/>


<h2 id="8.CreateBlogComment">4.9 Create Blog, Blog Entries and Comments</h2>
Creating a blog in Weceem requires just two steps:
<ul class="star">
<li>Create a Blog content node</li>
<li>Create a Blog Entry content node underneath (as a child of) the blog node</li>
</ul><p class="paragraph"/>If you are using the default styling, when you create the Blog you can set the Template to the default blog template
supplied.<p class="paragraph"/>Blogs in Weceem are just like any other content, and by gluing together a Template, some Widgets and some Weceem GSP
ags, you get full blog functionality (caveat: pinging blog aggregators is not yet supported). See the examples in the
default space template for further details.<p class="paragraph"/>To enable comments on your blog you must edit your Weceem security policy file and allow unauthenticated users to create
content of type org.weceem.content.WcmComment. Make sure that you do this for only that type, or
malicious users may be able to create non-Comment content on your site!<p class="paragraph"/>The default space template for blogs uses widgets to render a single blog entry view, or a list of the most recent
posts, and widgets to render the comment form and list of current comments.<p class="paragraph"/>The generic content submission mechanism of Weceem is used to submit comments by users, and the comment widget uses the
Weceem content submission tags to set this up.<p class="paragraph"/>The Weceem archive tags are used to render the months for which there exist child nodes of type "Comment", with links to
view those. Finally, the widgets render the list of tags assigned to the blog entry, with links to search for other blog
entries based on those tags.<p class="paragraph"/>For preparing new blog, the user needs to select row in the
content repository tree by clicking on it. As the result the row is preselected by color. The row selection means that
the content will be child to selected content. Then at the top of <strong class="bold">Content</strong> tab there is a button <strong class="bold">New Content</strong> that
offers a list of available content types to be created. Select the type "Blog" and press "Create" button. The new
blog editor should be shown to the user<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/blogEditor.jpg"></img><p class="paragraph"/>If the Blog is created, then it is possible to create Blog Entries. The user should  select "Blog row" as a parent and
press <strong class="bold">New Content</strong> button to select <strong class="bold">Blog entry</strong> content type. The editor contains CKEditor for entering content.<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/createBlogEntry.jpg"></img><p class="paragraph"/>Also it is possible to create or manage existed Comments. If you put a submission form for your Blog Entry page then
the users will push comments to your through your site. Also you can create new Comment from "Content" tab by pressing
button "New Content" and selecting <strong class="bold">Comment</strong> content type.<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/createComment.jpg"></img><p class="paragraph"/><strong class="bold">Visitor comments and submitted content</strong><p class="paragraph"/>Sites often permit visitors to leave comments - be they blog comments, visitor books or comments on Wiki pages.<p class="paragraph"/>Weceem supports a generic mechanism for visitors to create new content nodes via a form, filtered through the security
policy.<p class="paragraph"/>This is, for example, how the default space implements comments on blogs. A widget is used to render a form to capture
the comment fields and submit them to Weceem's content submission controller - where they are, if the security policy
permits that kind of content at that URI, from that (anonymous) user - saved in an "unmoderated" status.
Creating a comment submission form<p class="paragraph"/>To allow users to submit content, you need to provide the data from the client browser - usually with a form that the
user completes. You will usually do this inside a Widget node so that the code can be reused:<p class="paragraph"/><div class="code"><pre>&#60;g:hasErrors bean=<span class="java&#45;quote">"$&#123;submittedContent&#125;"</span>&#62;
There were some errors on your submission, please check below
&#60;/g:hasErrors&#62;<p class="paragraph"/>&#60;wcm:submitContentForm parent=<span class="java&#45;quote">"$&#123;parentContent&#125;"</span> type=<span class="java&#45;quote">"org.weceem.content.WcmComment"</span> success=<span class="java&#45;quote">"$&#123;parentContent&#125;"</span>&#62;<p class="paragraph"/>&#60;bean:require beanName=<span class="java&#45;quote">"submittedContent"</span> className=<span class="java&#45;quote">"org.weceem.content.WcmComment"</span>/&#62;
&#60;bean:field beanName=<span class="java&#45;quote">"submittedContent"</span> property=<span class="java&#45;quote">"author"</span> label=<span class="java&#45;quote">"Your name"</span>/&#62;
&#60;bean:field beanName=<span class="java&#45;quote">"submittedContent"</span> property=<span class="java&#45;quote">"email"</span>/&#62;
&#60;bean:input beanName=<span class="java&#45;quote">"submittedContent"</span> property=<span class="java&#45;quote">"websiteUrl"</span> label=<span class="java&#45;quote">"Website URL"</span>/&#62;
&#60;bean:input beanName=<span class="java&#45;quote">"submittedContent"</span> property=<span class="java&#45;quote">"title"</span>/&#62;
&#60;bean:field beanName=<span class="java&#45;quote">"submittedContent"</span> property=<span class="java&#45;quote">"content"</span> label=<span class="java&#45;quote">"Your comment"</span>/&#62;
&#60;input type=<span class="java&#45;quote">"submit"</span> class=<span class="java&#45;quote">"button positive"</span> value=<span class="java&#45;quote">"Send comment"</span>/&#62;<p class="paragraph"/>&#60;/wcm:submitContentForm&#62;</pre></div><p class="paragraph"/>
Here, three different Grails taglibs are being used to create the form:
<ul class="star">
<li>  g:hasErrors is a Grails tag used to detect any errors on the submittedContent data and alerts the user if so</li>
<li>  wcm:submitContentForm creates a form that will submit content of a specific type, as set in the "type" attribute.</li>
</ul><p class="paragraph"/> The "parent" attribute must be set to the node that will be the parent of the new content (or null for root content),
 and the "success" attribute is the repository URI path or node that should be shown after the content has been
 submitted - e.g. the original Blog Entry
<ul class="star">
<li>  bean:* tags are from the Grails bean-fields plugin that is provided as part of Weceem. They make it easy to render</li>
</ul><p class="paragraph"/> sensible default fields, labels and error messages for properties of an object. In this case the object is the
 "submittedContent" bean used by the content submission form.<p class="paragraph"/>The form will include a link to the content submission controller. This controller will save the content if it is valid,
or return to the existing content with the "submittedContent" object populated with the previous data and any errors
attached. Using the bean:* tags of the Grails Bean-Fields plugin is merely a convenience, but is very useful as it will
display the validation errors associated with each field inline in the form.<p class="paragraph"/>If the submission succeeds - which requires the user to have permission to create that type of content under the
specified parent in the repository - it will redirect the user to the content specified in the "success" attribute.<p class="paragraph"/>The content will be in the "unmoderated" status, until an administrator updates the status to Published.<p class="paragraph"/><p class="paragraph"/>


<h2 id="9.CreateServerFolderFile">4.10 Server Directory and Server File</h2>
If the user needs to add some files, f.e. images then it is possible to create a "Server Directory" on a file system and put
your uploaded files as "Server File" there. Although there are special content types for CSS anf JS files such as
"CSS Stylesheet" and "JavaScript Source", but they are restricted to be no longer then <strong class="bold">500000</strong> symbols.
In case if the user wants to use the biggest CSS, JS libraries or images, the <strong class="bold">ServerFile</strong> is the type that is needed to
be used.<p class="paragraph"/>Firstly create <strong class="bold">Server Directory</strong>  - the folder on the file system will be created, then put your uploaded files
as <strong class="bold">Server Files</strong> to this directory.<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/createServerDirectory.jpg"></img><p class="paragraph"/>
<img border="0" class="center" src="../img/usersGuide/createServerFile.jpg"></img><p class="paragraph"/>


<h2 id="10.CreateTemplateWidget">4.11 Templates and Widgets</h2>
If the user needs to prepare template, he needs to select row in the content repository tree by clicking on it. As the
result the row is preselected by color. The row selection means that the content will be child to selected content. Then
at the top of <strong class="bold">Content</strong> tab there is a button <strong class="bold">New Content</strong> that offers a list of available content types to be created.
Select the type "Template" and press "Create" button. The new content editor should be shown to the user. Usually the
template is a GSP page that uses Weceem tags for rendering necessary content. Check <strong class="bold">Tags</strong> section for more details.<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/createTemplate.jpg"></img><p class="paragraph"/>Also it is possible to create widgets, by selecting content type "Widget" to prepare widgets for templates. Usually
template is consists from widgets as from blocks. It helps template to be more flexible and customizable.<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/createWidget.jpg"></img>



<h2 id="11.CreateAction">4.12 Create Action</h2>
It is possible to create content Action that is determined with Groovy Script that should be executed. For example,
sending mails of checking links on the page. To create new Action is possible using button "New Content" at the top of
repository tree and selecting content type <strong class="bold">Action</strong> in the available content types. The simple editor is available for
creating user Actions.<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/createAction.jpg"></img><p class="paragraph"/><p class="paragraph"/>


<h2 id="12.CreateBinaryContent">4.13 Create Binary Content</h2>
The content type <strong class="bold">Binary Content</strong> represents files, that are stored in the data base using base64 encoding.
Don't use it for large content. It is intended for logos etc. To create such content, please check that at the top of
<strong class="bold">Content</strong> tab there is a button <strong class="bold">New Content</strong> that offers a list of available content types to be created. Select the
type "Binary Content" and press "Create" button. The new editor similar to <strong class="bold">Server File</strong> editor should be shown to the
user<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/createBinaryContent.jpg"></img>


<h2 id="13.CreateCssJs">4.14 Create CSS Stylesheets and Javascript Sources</h2>
There are two ways to create JavaScript and CSS resources in Weceem.<p class="paragraph"/>You can upload JS and CSS files to "Server File" content nodes, or you create JavaScript and Stylesheet nodes and edit
the files directly in Weceem.<p class="paragraph"/>Whichever approach you choose, you include these files in your Template or Widget nodes something like this:<p class="paragraph"/><div class="code"><pre>&#60;html&#62;
&#60;head&#62;
&#60;link rel=<span class="java&#45;quote">"stylesheet"</span> href=<span class="java&#45;quote">"$&#123;wcm.createLink(path:'css/main.css')&#125;"</span>/&#62;
&#60;script type=<span class="java&#45;quote">"text/javascript"</span> src=<span class="java&#45;quote">"$&#123;wcm.createLink(path:'js/main.js')&#125;"</span>&#62;&#60;/script&#62;
&#60;/head&#62;
&#8230;
&#60;/html&#62;</pre></div><p class="paragraph"/>Here we just use the wcm.createLink tag to get the URL to the content nodes. Whether you used Server File or
Stylesheet/JavaScript nodes for these files, this will produce the correct URL if the "path" value points to the
correct nodes. Note that the Alias URI of the nodes should include the file extension although it does not have to.
Some older browsers may require the file extension for correctly identifying the content type.<p class="paragraph"/>You can of course place these files anywhere in your repository as long as you use the correct content path URI.<p class="paragraph"/>Note that if your CSS files need to reference external resources like images, you will need to make sure the links make
sense in relation to the content repository. Relative links will work for Server File nodes, which must be under a
Server Directory node. However a Server Directory node cannot have StyleSheet or JavaScript child nodes, so usually if
you need to link to relative images from a stylesheet, you will need to upload it as a Server File instead of a
StyleSheet node. That is, unless you have a Server Directory node that is a sibling to the StyleSheet node, and you
place your images under there.<p class="paragraph"/>At the top of <strong class="bold">Content</strong> tab there is a button <strong class="bold">New Content</strong> that offers a list of available content types to be created.
Select the type "CSS Stylesheets" or "JavaScript Sources" and press "Create" button. The simple content editor should be
shown to the user.<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/createCss.jpg"></img><p class="paragraph"/>
<img border="0" class="center" src="../img/usersGuide/createJs.jpg"></img>


<h2 id="14.CreateExternalLink">4.15 Create External Link</h2>
The user has possibility to create content with the type "<strong class="bold">External Link</strong>". This content type is representing a link to
an external URL . To create new <strong class="bold">External Link</strong>, check at the top of <strong class="bold">Content</strong> tab there is a button <strong class="bold">New Content</strong> that
offers a list of available content types to be created. Select the type "External Link" and press "Create" button. The
special content editor should be shown to the user.<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/externalLink.jpg"></img>


<h2 id="15.CreateGroovyScript">4.16 Create Groovy Script</h2>
It is possible to create Groovy Scripts, that can be used for creating new content Actions. For that aim at the top of
<strong class="bold">Content</strong> tab there is a button <strong class="bold">New Content</strong> that offers a list of available content types to be created. Select the
type "Groovy Script" and press "Create" button. The special content editor should be shown to the user.<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/createGroovyScript.jpg"></img>


<h2 id="16.CreateFolder">4.17 Create Folder</h2>
It is possible to create Folders in content repository tree. The Folders usually used to organize content by types or
logically. For example, the user can create Folders "CSS" and "JavaScript" and put CSS Stylesheets and JavaScript
sources in them respectively.<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/createFolder.jpg"></img>


<h2 id="17.CreateWikiPage">4.18 Create Wiki page</h2>
It is possible to create <strong class="bold">Wiki page</strong> content by using button "New Content" at the top of repository tree and selecting
content type <strong class="bold">Wiki Page</strong> in the available content types. The editor is available for creating new content.<p class="paragraph"/>
<img border="0" class="center" src="../img/usersGuide/createWikiPage.jpg"></img><p class="paragraph"/><p class="paragraph"/>


<h2 id="18.CreateVirtualContent">4.19 Create Virtual Content</h2>
There is a possibility to create virtual content for any existed content in the content repository tree. For that aim,
please check button "New Content" at the top of repository tree and select content type <strong class="bold">Virtual Content</strong> in the
available content types. Each <strong class="bold">Virtual Content</strong> is determined by its "target" - the content node from repository tree.<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/createVirtualContent.jpg"></img><p class="paragraph"/>



<h2 id="19.StatusPublishing">4.20 Statuses, Publishing and Unpublishing by date</h2>
The statuses are very important part in content management. According to status of a content it can be shown, hidden,
publish or unpublish by specified date.<p class="paragraph"/>The following Statuses are provided:
<ul class="star">
<li>Draft</li>
<li>Unmoderated</li>
<li>Reviewed</li>
<li>Approved</li>
<li>Published</li>
<li>Archived</li>
</ul><p class="paragraph"/>Each status has a numerical code - e.g. Draft is 100, Unmoderated - 150, Published - 400 etc. Each status has a flag to
indicate whether or not it is "public" content i.e. can be viewed by non-administrators.
By default <strong class="bold">Published</strong> is the only status with this flag set.<p class="paragraph"/>All changes to status are made manually by repository users, unless the <strong class="bold">Publish From</strong> or <strong class="bold">Publish Until</strong> fields have
values.<p class="paragraph"/>In the case of <strong class="bold">Publish From</strong>, once the date passes, the status of the content will change to the first status with
"public content" flag switched on, which has a higher code number than the current status of the content. This offers
scope for other statuses beyond the existing set, and migration upward through those states.<p class="paragraph"/>The one caveat here is that the <strong class="bold">Publish From</strong> mechanism will never change the status on content that is currently in
the "Unmoderated" or "Archived" status used for visitor-submitted or expired content. If you need to change which status
is used for "Unmoderated" or "Archived" content you can do this by setting the configuration variables to the numerical
code values of the desired status <strong class="bold">weceem.unmoderated.status</strong> and <strong class="bold">weceem.archived.status</strong><p class="paragraph"/>With <strong class="bold">Publish Until</strong>, the status of any published content that has expired will be set to the "Archived" status or the
status defined in the configuration variable <strong class="bold">weceem.archived.status</strong>.<p class="paragraph"/><p class="paragraph"/><p class="paragraph"/>


<h2 id="20.Search">4.21 Search in Weceem</h2>
Weceem has full-text search support for visitors using your site.<p class="paragraph"/>All of your content is automatically indexed as appropriate, all you need to do is add a way for them to start a search,
and customise the display of the search results.<p class="paragraph"/>To add a default search field, you can use the wcm:search tag:<p class="paragraph"/><div class="code"><pre>&#60;wcm:search types=<span class="java&#45;quote">"org.weceem.html.WcmHTMLContent,
     org.weceem.blog.WcmBlogEntry,org.weceem.content.WcmComment"</span>/&#62;</pre></div><p class="paragraph"/>This single tag creates the search field and button, which you can style with standard CSS. The "types" attribute is
used to limit the types of content that can be returned by the search. You usually don't want your Widgets, CSS or
JavaScript code coming back in search results! This also means you can have different searches on your side, for
different kinds of content, including custom content types. For example you may have a custom ProductInformation
content type and want to add a product-only search feature for users.<p class="paragraph"/>Other attributes of this tag allow you to control the parent URI to use as the context for the search, and the content
path for the results path which will render the search results. For full details see the wcm:search tag page.<p class="paragraph"/>You can also create a completely customized search form and use wcm:searchLink to create the appropriate link to invoke
the search for the types and other attributes you specify.<p class="paragraph"/><p class="paragraph"/>


<h2 id="21.DragAndDrop">4.22 Operations with content repository tree</h2>
There is a list of operations that can be done with content repository tree. The button with dropping menu items is
situated above the content repository tree, it is called "<strong class="bold">More Actions</strong>". The following operations are available:
<ul class="star">
<li>Preview selected content</li>
<li>Delete content</li>
<li>Move to Space</li>
<li>Duplicate...</li>
</ul><p class="paragraph"/><strong class="bold">Preview selected</strong> opens a new page/tab with the content previewing. Not all types of a content can be previewed, for
example Templates and Widgets cannot be previewed as standalone pages. If the user tries to get preview for them the
special message (or error page - depends on configuration settings) will be displayed.<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/previewError.jpg"></img><p class="paragraph"/><strong class="bold">Delete</strong> content gives the user possibility to delete selected content. If the content contains children, the error
message will be displayed and content won't be deleted.<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/deleteError.jpg"></img><p class="paragraph"/><strong class="bold">Move to Space</strong> operation should move content from one Space to another one, but currently not implemented yet.<p class="paragraph"/><strong class="bold">Duplicate</strong> should copy the selected content to the other holder, parent content or even in another Space, but
currently not implemented yet.<p class="paragraph"/>Also there are several operations that can be done on content repository tree, f.e. the user can drag a content and
drop it as a child to another content. It is possible such way to move or copy the content to the another location.<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/dropAction.jpg"></img><p class="paragraph"/>



<h2 id="22.TagsAndJspContent">4.23 Tags and JSP content</h2>
Weceem is built with Grails which provides a technology called Groovy Server Pages. In essence, it allows you to embed
special tags in the content to perform special functions or logic. Some content types in Weceem (Template, Widget and
HTML) support the use of these tags to provide advanced features.<p class="paragraph"/>To users of JSP (Java Server Pages) this will be a familiar concept.<p class="paragraph"/>These custom tags or "GSP tags" as they are called, use the XML namespacing syntax:<p class="paragraph"/>Search:
<div class="code"><pre>&#60;wcm:search/&#62;</pre></div><p class="paragraph"/>The "wcm:" prefix is the Weceem tag namespace. This tells you it is a Weceem-specific tag you are using. Grails provides
its own "g:" namespace for basic built-in functions like link creation, iteration over items in a list and so on.<p class="paragraph"/>Attributes can be passed to these tags as you would with HTML, with the addition of a Groovy-based "Expression Language"
(EL) that lets you pass around variables that are available to the page or execute small pieces of code to perform
calculations. These are put inside a dollar and brace syntax "${...}":<p class="paragraph"/><div class="code"><pre>&#60;g:each in=<span class="java&#45;quote">"$&#123;node.lineage&#125;"</span>&#62;
$&#123;node.title.encodeAsHTML()&#125;&#60;br/&#62;
&#60;/g:each&#62;</pre></div><p class="paragraph"/>The above would iterate over every item in the "lineage" property of the "node" object. The "node" object represents the
current content node being rendered. See the reference section on page variables for more details of the available
objects.<p class="paragraph"/>You will see here also that the EL can be used outside of tag attributes, to render information into the page output.
As a side-note, the encodeAsHTML() method called in that example escapes the resulting title text so that it is safe for
inclusion in HTML output (it escapes special characters to HTML entities). This encodeAs functionality is provided by Grails.<p class="paragraph"/>Using these features you can code your Template and Widget nodes to perform all kinds of powerful functions, from
listing child nodes of the current page, to generating RSS feeds. See the Weceem tag reference for full details.<p class="paragraph"/>



<h2 id="23.ReusingCodeWithWidgets">4.24 Reusing code and page fragments with Widgets</h2>
While Templates are used for laying out a page, Widgets are used to render fragments within a page. These might be page
content such as header/footer text or reusable code that renders a list of news items.<p class="paragraph"/>Widgets can use the same GSP tags as Templates, which makes them very powerful. The News content on the home page of
this site is a Widget, and the default space renders blog entries using Widgets.<p class="paragraph"/>To render widgets inside a Template (or GSP-enabled HTML content node) you use the &#60;wcm:widget&#62; tag:<p class="paragraph"/><div class="code"><pre>&#60;html&#62;
  &#60;head&#62;
    &#60;wcm:widget path=<span class="java&#45;quote">"widgets/resources"</span>/&#62;
    &#60;wcm:widget path=<span class="java&#45;quote">"widgets/metatags"</span>/&#62;
  &#60;/head&#62;
  &#60;body&#62;
    &#60;wcm:widget path=<span class="java&#45;quote">"widgets/header"</span>/&#62;
    &#60;wcm:content/&#62;
    &#60;wcm:widget path=<span class="java&#45;quote">"widgets/footer"</span>/&#62;
  &#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>The above could be used as a generic template for content, pulling in your standard SEO meta tags from a "metatags"
widget, and JS and CSS resources from a widget called "resources".<p class="paragraph"/>The "resources" widget might look something like this:<p class="paragraph"/><div class="code"><pre>&#60;link rel=<span class="java&#45;quote">"stylesheet"</span> type=<span class="java&#45;quote">"text/css"</span> href=<span class="java&#45;quote">"$&#123;wcm.createLink(path:'css/main.css')&#125;"</span>/&#62;
&#60;script type=<span class="java&#45;quote">"application/javascript"</span> src=<span class="java&#45;quote">"$&#123;wcm.createLink(path:'js/jquery.js')&#125;"</span>/&#62;</pre></div><p class="paragraph"/>This uses the &#60;wcm:createLink&#62; tag to get the full URI to the resources within the current space.


<h2 id="24.UsingImagesInHtml">4.25 Using images in HTML content</h2>
To insert images into HTML content, you use the image icon on the rich text editor's toolbar.<p class="paragraph"/>This will allow you to:
<ul class="star">
<li>upload a new image</li>
<li>use one that has been uploaded already</li>
<li>insert a URL to an image on the web</li>
</ul><p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/imgEditor.jpg"></img><p class="paragraph"/>When using the option to upload or browse the images on the server, the files will be located in the "/Image" folder on
your server (&#60;weceem-application-path&#62;/WeceemFiles/&#60;space-alias&#62;/Image).<p class="paragraph"/>If you have uploaded files as Server File nodes, if you did not put them inside the /Image folder then they will not be
visible to the FCK file editor browser, but you can still link to them by entering in their full or relative URI.


<h2 id="25.UploadingAndLinking">4.26 Uploading and linking to files</h2>
There are two ways to upload files to your Weceem content repository.<p class="paragraph"/><strong class="bold">Creating Server File nodes</strong><p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/createServerFile.jpg"></img><p class="paragraph"/>When you create a Server File node in the repository, it will be uploaded from the Weceem editor into the server
directory allocated to the space, at a path defined by the Alias URIs of its ancestor Server Directory nodes.<p class="paragraph"/>Once the file has been uploaded it cannot be changed - the node can be deleted and the file will also be deleted.<p class="paragraph"/>You link to server file nodes in the same way as you do any other content, using the wcm.createLink or wcm.link tags.<p class="paragraph"/><strong class="bold">Uploading while editing HTML content</strong><p class="paragraph"/>You can also upload files - most likely images - using the file uploader in the rich HTML editor when editing a HTML
content node. It is important to note that all such files are uploaded to a <strong class="bold">/Image</strong> folder under your space's server
folder. Server File nodes will not automatically be created for these, and they are not needed - unless you use the
"Synchronize Files" option in the Administration section of Weceem.


<h2 id="26.ControllingAccess">4.27 Controlling who can see content and when</h2>
With Weceem you can restrict who can view your content by user role, as well as the date period during which the content
is available.<p class="paragraph"/><strong class="bold">Automatic publishing and removal of content</strong><p class="paragraph"/>Every type of content has a Status, a Publish From and a Publish Until field. Together these work to provide a simple
automatic publishing workflow.<p class="paragraph"/><strong class="bold">Writing content for automatic publishing later</strong><p class="paragraph"/>To write content today but have it available to view only at some point in the future you just do the following:
<ul class="star">
<li>  Set the status of the content to Draft, Approved or some other non-"published" status (apart from Archived!)</li>
<li>  Set a value in the Publish From field in the "Extras" section of the editor</li>
</ul><p class="paragraph"/>Once saved, Weceem will automatically publish your content when the time has passed (within a minute or so of the time)
by moving it into the Published status.<p class="paragraph"/><strong class="bold">Writing content that disappears after a certain date and time</strong><p class="paragraph"/>To perform the opposite - automatic removal of public content - you simply set the Publish Until date and time on your
content. When this time has passed, the content will be put into the "Archived" status which is not visible to the
public. You will still be able to view the content in the repository.<p class="paragraph"/><strong class="bold">Restricting access by user</strong><p class="paragraph"/>To limit the content that different users can view, you need to edit your Weceem security policy file.<p class="paragraph"/>All that is required is that you grant the "view" permission only on the URIs and content types that you wish the user
role to be able to see.


<h2 id="27.MultiLanguageSite">4.28 Creating sites with content in different languages</h2>
Often your site will need to present content in multiple languages. You may provide translations of your site, say in
French and German as well as your primary language.<p class="paragraph"/><img border="0" class="center" src="../img/usersGuide/weceemLanguages.jpg"></img><p class="paragraph"/>It is often the case that not only does the text differ in other languages, but images, CSS and other resources may have
differ, and in fact due to different territory restrictions you may have very different content for each language.<p class="paragraph"/>With this in mind, the recommended way to achieve this in Weceem is to create a Folder node for each language you
support, and add the translated content under those folder nodes. For content that is the same as the primary language,
you could create Virtual Content nodes to "defer" to the original primary content.<p class="paragraph"/>To give your users access to this content, you simply add some links or a selection box to your page templates - so they
click on the language they want and it takes them to the content for that language.


<h2 id="28.PerformanceAndCache">4.29 Site performance and caching content</h2>
Processing and rendering content in a CMS is a relatively time consuming activity, particularly with complex pages that
render external feeds or loop over other content nodes.<p class="paragraph"/>So as with regular websites it makes sense to use standard browser caching features to reduce the number of requests for
content and supporting HTTP mechanisms for detecting changes to content.<p class="paragraph"/>Weceem supports both of these aims by implementing smart ETag handling as well as allowing you to tell the browser how
long to keep the content for before checking for new versions using ETag. With ETags, the browser still makes a request
to the server to check for changes, but if there has been no change, receives no new content.<p class="paragraph"/>This is done by calculating ETags for all URIs in your repository, based on the contents of other nodes on which those
depend. For example even a simple home page is dependent on at least a Template node and likely at least a couple of
widgets. This information is cached by Weceem, so checking for new content is very quick.<p class="paragraph"/>However this means that the ETag for your home page must change if the Template or widgets have been edited - otherwise
users will continue to see your old home page styling for some time.<p class="paragraph"/>Weceem handles this by allowing you specify the URIs of content that a node is dependent on, a "maximum age" and also
whether content contains user-specific information (which means that a different ETag is used per user).<p class="paragraph"/><strong class="bold">Content Dependencies</strong><p class="paragraph"/>When editing content, there is a "Content dependencies" field in the Advanced settings. This is where you enter a
comma-delimited list of URIs on which the content node depends. By dependency we mean that this content's visual
representation may change if any of these nodes are changed.<p class="paragraph"/>Wild cards of the form /<strong class="bold"></strong> are supported, to represent any dependents.<p class="paragraph"/>There is however no need to specify dependency on the content Template, because this is handled automatically for you.<p class="paragraph"/>For example a Template used for your entire site may render widgets for header and footer. If you want all content that
uses this template to become invalidated if the header or footer change, you would set the content dependencies to e.g:<p class="paragraph"/>widget/header, widget/footer<p class="paragraph"/>If you had a dependency on a lot of widgets, you could simplify this with the wildcard:<p class="paragraph"/>widget/<strong class="bold"></strong><p class="paragraph"/>Another example is a News widget that uses wcm:eachChild to iterate over the news article nodes at URI "news-articles".
Here you'd set the content dependencies of the widget to:<p class="paragraph"/>news-articles/<strong class="bold"></strong><p class="paragraph"/>This way, any template that depends on this news widget, will also depend on the news articles, and hence everything
invalidates as appropriate.<p class="paragraph"/>NOTE: some content types are smart and add some implicit dependencies. For example Blog automatically depends on its
BlogEntry children. This is required because a Blog page normally lists its child nodes, and needs to update if new
entries are added.<p class="paragraph"/><strong class="bold">Controlling how long a browser may keep a cached page</strong><p class="paragraph"/>Aside from the dependencies, you can tell the browser how long to wait before checking for new content. For example if
you know that usually you don't post more than one news article per day, and that even if you did you didn't mind
someone not seeing the very latest, you can tell Weceem this.<p class="paragraph"/>Each content node has a setting labelled "Is updated" in Advanced. Here you can select how often the node is likely to
be updated. If you never want it to be cached you can set this to "All the time". If you know that the content is
unlikely to change you can set it to something like "Weekly" or "Never"<p class="paragraph"/>Doing this reduces the requests made to your server - saving you CPU time and bandwidth, and improving the response time
of your site for users.<p class="paragraph"/>Note that if a user uses the "refresh" button in their browser, they will always get the newest content.<p class="paragraph"/><strong class="bold">User-specific content</strong><p class="paragraph"/>In some cases you may use Weceem's advanced scripting and widget features to present user-specific information. This
typically uses the HTTP session to store user information, such as the contents of a shopping cart, or their user ID.<p class="paragraph"/>By ticking the "User specific content" option (available on Template nodes only in 1.0), you can instruct Weceem to
allow the client to use cached content but still update if that user's rendering of the content will have changed.<p class="paragraph"/>When checked, this option forces Weceem to create a user-specific ETag for the content using that template. This is done
by monitoring the HTTP session for changes. Any changes to the HTTP session result in a new ETag for pages using
that template.<p class="paragraph"/>If you have other data changes that should invalidate the user's view of the content, but don't directly change the
session, you can force this simply by writing to the session.<p class="paragraph"/>For example if you have a Widget that renders a log in / log out button depending on whether the user has a cookie or
not (perhaps for a separate app on the same domain) you simply make that widget set a variable in the session if the
cookie value is no longer present:<p class="paragraph"/><div class="code"><pre>&#60;g:set <span class="java&#45;keyword">var</span>=<span class="java&#45;quote">"hasCookie"</span> value=<span class="java&#45;quote">"$&#123;request.cookies.find &#123; it.name == 'userInfo' &#125;?.value&#125;"</span>/&#62;<p class="paragraph"/>&#60;%&#45;&#45; only <span class="java&#45;keyword">if</span> the presence of cookie has changed to we change the session &#45;&#45;%&#62;
&#60;g:<span class="java&#45;keyword">if</span> test=<span class="java&#45;quote">"$&#123;session.userLoggedIn != hasCookie&#125;"</span>&#62;
   &#60;g:set <span class="java&#45;keyword">var</span>=<span class="java&#45;quote">"userLoggedIn"</span> scope=<span class="java&#45;quote">"session"</span> value=<span class="java&#45;quote">"$&#123;hasCookie&#125;"</span>/&#62;
&#60;/g:<span class="java&#45;keyword">if</span>&#62;<p class="paragraph"/>&#60;%&#45;&#45; render the links &#45;&#45;%&#62;
&#60;g:<span class="java&#45;keyword">if</span> test=<span class="java&#45;quote">"$&#123;hasCookie&#125;"</span>&#62;
  &#60;wcm:link path=<span class="java&#45;quote">"user/logout"</span>&#62;Log out&#60;/a&#62;
&#60;/g:<span class="java&#45;keyword">if</span>&#62;
&#60;g:<span class="java&#45;keyword">else</span>&#62;
  &#60;wcm:link path=<span class="java&#45;quote">"user/login"</span>&#62;Log in&#60;/a&#62;
&#60;/g:<span class="java&#45;keyword">else</span>&#62;</pre></div>



<h2 id="29.PublishingFeeds">4.30 Publishing Feeds</h2>
You can expose RSS/Atom feeds of any list of child nodes in your repository with a simple tag, wcm:feedLink.<p class="paragraph"/>This tag will create the correct &#60;meta&#62; tag in the HEAD section of your HTML so that any RSS readers that request the
feed will get a list of nodes in reverse date order:<p class="paragraph"/><div class="code"><pre>&#60;head&#62;
&#60;wcm:feedLink type=<span class="java&#45;quote">"rss"</span> path=<span class="java&#45;quote">"$&#123;node&#125;"</span>/&#62;
&#60;/head&#62;</pre></div><p class="paragraph"/>This would add a feed for the children of the current page. For full details see <strong class="bold">Tags</strong> section.


<h1 id="5.WeceemSecuritPolicy">5 Weceem security policy</h1>
The Weceem security policy file is a Groovy script in your server filesystem, that lets you control who can access your content and what they can do with it.<p class="paragraph"/>The security policy uses information about the currently-logged in user's roles as supplied by the integration with your authentication system.<p class="paragraph"/>The security system gives you control over:
<ul class="star">
<li>spaces that users in different roles can access</li>
<li>URI paths in each space these users can access</li>
<li>permissions (admin, create, update, delete, view) the users have for these URI paths</li>
<li>the types of content nodes for which the users have these permissions</li>
</ul><p class="paragraph"/>So in combination, you can control how people interact with your site - like offering protected areas for known users, and allowing comments from site visitors on some content and not others.<p class="paragraph"/><h4>Setting a security policy</h4><p class="paragraph"/>The Weceem plugin automatically looks for a security policy - which is a Groovy script - using the following logic:
<ol>
<li>It looks to see if the Grails configuration variable "weceem.security.policy.path" has a value set by the Grails application's Config.groovy.</li>
<li>If so, it uses that as the file path. If that variable is not set, it will look for the system property "weceem.security.policy.path" and use that if set.</li>
<li>If neither are set, it will initialize with default permissions where ROLE_ADMIN can do anything, ROLE_USER can create/edit content, and ROLE_GUEST can only view.</li>
</ol><p class="paragraph"/><h4>How to write a Weceem security policy</h4><p class="paragraph"/>Weceem plugin does not predefine any security role names - role names are just strings that your authentication system associates with users. The Weceem application happens to use Acegi/Spring security and is coded to supply roles called ROLE_ADMIN, ROLE_USER and ROLE_GUEST, but you are not limited to using these names.<p class="paragraph"/>Here's an example policy :<p class="paragraph"/><div class="code"><pre>// The policy closure must be assigned to the policy variable
policy = &#123;<p class="paragraph"/>  // Here we define a role &#45; <span class="java&#45;keyword">this</span> can be anything your authentication
  // system provides, but with Weceem Application edition, ROLE_GUEST, ROLE_USER,
  // and ROLE_ADMIN are used.
  // Note also that Weceem automatically adds the user's login as a special role
  // eg. user <span class="java&#45;quote">"fred"</span> automatically has a role added called <span class="java&#45;quote">"USER_fred"</span> <span class="java&#45;keyword">for</span> easy per&#45;user
  // access control
  'ROLE_ADMIN' &#123;
    // We're defining permissions <span class="java&#45;keyword">for</span> any space so use '&#42;'. Alternatively
    // specify a list of space alias URIs eg: space 'internal', 'extranet' (no square brackets!)
    space '&#42;'<p class="paragraph"/>    // Control whether <span class="java&#45;keyword">this</span> role can access Weceem admin functions eg edit/create spaces
    admin <span class="java&#45;keyword">true</span><p class="paragraph"/>    // Control whether <span class="java&#45;keyword">this</span> role can create <span class="java&#45;keyword">new</span> content in <span class="java&#45;keyword">this</span> space
    create <span class="java&#45;keyword">true</span><p class="paragraph"/>    // Control whether <span class="java&#45;keyword">this</span> role can edit content in <span class="java&#45;keyword">this</span> space
    edit <span class="java&#45;keyword">true</span><p class="paragraph"/>    // Control whether <span class="java&#45;keyword">this</span> role can view content in <span class="java&#45;keyword">this</span> space
    view <span class="java&#45;keyword">true</span><p class="paragraph"/>    // Control whether <span class="java&#45;keyword">this</span> role can delete content in <span class="java&#45;keyword">this</span> space
    delete <span class="java&#45;keyword">true</span>
  &#125;<p class="paragraph"/>  'ROLE_USER' &#123;
    space '&#42;'
    admin <span class="java&#45;keyword">false</span>
    create <span class="java&#45;keyword">true</span>
    edit <span class="java&#45;keyword">true</span>
    view <span class="java&#45;keyword">true</span>
    delete <span class="java&#45;keyword">false</span>
  &#125;<p class="paragraph"/>  'ROLE_GUEST' &#123;
    space '&#42;'
    admin <span class="java&#45;keyword">false</span>
    create <span class="java&#45;keyword">false</span>
    edit <span class="java&#45;keyword">false</span>
    view <span class="java&#45;keyword">true</span>
    delete <span class="java&#45;keyword">false</span><p class="paragraph"/>    // Here we have URI&#45;specific access restriction
    // We prevent guests from viewing the extranet
    <span class="java&#45;quote">"customers/extranet"</span> &#123;
      view <span class="java&#45;keyword">false</span>
    &#125;<p class="paragraph"/>    <span class="java&#45;quote">"blog"</span> &#123;
      // Limit creation to comments on blog only
      create types:&#91;org.weceem.content.WcmComment&#93;
    &#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>Per-URI permissions can set the same permissions that can be set on the space, and these take precedence. The permissions defined for the space are used as a fallback if there is no matching per-URI permission defined for that role.<p class="paragraph"/>So you can set "view false" on the spaces but then open up parts of the URI with "view true", or the other way around - however you like.<p class="paragraph"/>To specify permissions for certain content types only - specify a list of types instead of true/false, as is the case in the example above that permits users with ROLE_GUEST to only create WcmComment nodes and even then, only under the /blog/ part of the site.<p class="paragraph"/>This "types" list is a list of content classes that must be available on the classpath.



<h1 id="customization">6 Developer Guide</h1>
This section covers the internal details that can be used to customize Weceem within your application, create custom
content types and other more technical subjects.


<h2 id="0.HookingIntoTheAdminInterface">6.1 Hooking into the Admin interface</h2>
<strong class="bold">Hooking into the Admin interface of Weceem</strong><p class="paragraph"/>Applications can add items to the Weceem "Administration" page by using the Navigation plugin that Weceem CMS uses, to add items to the navigation group "weceem.app.admin". The Weceem Application does this :<p class="paragraph"/><div class="code"><pre>class UserController &#123;
        def authenticateService<p class="paragraph"/>        <span class="java&#45;keyword">static</span> navigation = &#91;group: 'weceem.app.admin', action: 'list', title: 'users'&#93;
&#125;</pre></div><p class="paragraph"/>The navigation plugin uses this convention property to place the "list" action of the user controller into the "Administration" section of Weceem Admin.


<h2 id="1.CreateCustomContentTypes">6.2 Create custom content types</h2>
Weceem provides many content types as standard. Each content type has a specific purpose, with different fields in the editor.<p class="paragraph"/>Some content types are directly rendered when requested, others are used by other content nodes to compose the page seen by the user.<p class="paragraph"/>The standard content types available in Weceem are :
<ul class="star">
<li>Action - A server-side action that will execute the code in a Groovy Script node, for example to create new content nodes or send an email</li>
<li>Blog - The root node of a Blog, which has Blog Entry nodes as children</li>
<li>Blog Entry - An entry (child of) a Blog node</li>
<li>Comment - A comment on a content node. Any nodes can have comments attached or created.</li>
<li>External Link - A URL of another website. When this URI is rendered, it redirects to the external site</li>
<li>Folder - A folder for grouping together content nodes and creating URI hierarchy</li>
<li>Groovy Script - A piece of Groovy code to execute on the server, used by Action nodes</li>
<li>HTML - A piece of HTML which may contain GSP (Grails Server Page) tags</li>
<li>JavaScript - A piece of JavaScript source</li>
<li>Server File - A file uploaded to the Weceem repository and stored on the server filesystem, e.g. an image file</li>
<li>Server Directory - A directory on the server filesystem which contains Server File nodes</li>
<li>Stylesheet - A CSS style sheet</li>
<li>Template - A GSP template used to layout and decorate the current content node</li>
<li>Widget - A reusable GSP fragment for rendering sections of a page, e.g. a header/footer or a remote news feed.</li>
</ul><p class="paragraph"/><h4> Creating custom content types</h4><p class="paragraph"/>You can add new content types that will be editable by your users and displayed in the repository along with the standard content types.<p class="paragraph"/>These custom types can have full control over how a request is handled (e.g. issue a redirect, like WcmExternalLink does) or delegate to established rendering mechanisms within Weceem. You might have it call out to a PDF generator for example, or render some data using an alternative presentation technology e.g. wiki rendering or Freemarker. They can also specify how their properties should be edited in the repository, and hook into events.<p class="paragraph"/>To create a new content type, you just need to create a new Grails domain class that extends the WcmContent class and follow a few simple conventions. You can create a basic template for a new content type using the create-content-class script :<p class="paragraph"/><div class="code"><pre>grails create&#45;content&#45;class com.mycompany.Product</pre></div><p class="paragraph"/>This will create the domain class under grails-app/domain/, with some default placeholder code. Here is an of the contentions.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.weceem.util.ContentUtils
<span class="java&#45;keyword">import</span> org.weceem.content.WcmContent<p class="paragraph"/>class PressRelease <span class="java&#45;keyword">extends</span> WcmContent &#123;<p class="paragraph"/>    // Set to <span class="java&#45;keyword">false</span> <span class="java&#45;keyword">if</span> <span class="java&#45;keyword">this</span> content node should never actually be rendered
    // i.e. Groovy Script nodes cannot be rendered directly.
    <span class="java&#45;keyword">static</span> standaloneContent = <span class="java&#45;keyword">false</span><p class="paragraph"/>    <span class="java&#45;object">String</span> getMimeType() &#123; <span class="java&#45;quote">"text/html"</span> &#125;<p class="paragraph"/>    <span class="java&#45;object">String</span> content<p class="paragraph"/>    /&#42;&#42;
     &#42; Must be overriden by content types that can represent their content as text.
     &#42; Used <span class="java&#45;keyword">for</span> search results and versioning
     &#42;/
    <span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> getContentAsText() &#123; ContentUtils.htmlToText(content) &#125;<p class="paragraph"/>    /&#42;&#42;
     &#42; Should be overriden by content types that can represent their content as HTML.
     &#42; Used <span class="java&#45;keyword">for</span> wcm:content tag (content rendering)
     &#42;/
    <span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> getContentAsHTML() &#123; content &#125;<p class="paragraph"/>    <span class="java&#45;keyword">static</span> constraints = &#123;
        content(nullable: <span class="java&#45;keyword">false</span>, maxSize: 65536)
    &#125;<p class="paragraph"/>    <span class="java&#45;keyword">static</span> editors = &#123;
        content(editor:'HtmlCode')
    &#125;<p class="paragraph"/>    <span class="java&#45;keyword">static</span> transients = WcmContent.transients
&#125;</pre></div><p class="paragraph"/>It declares a new type which, when created, will immediately become editable in the repository when you run your application.  There are several conventions that apply, described in more detail below -<p class="paragraph"/><strong class="bold">Basic considerations</strong><p class="paragraph"/>Your descendent class has certain conventions it must honour for correct operation :
<ul class="minus">
<li> the Grails "transients" property must be populated with the sum of the superclass transients and any new transient properties you add (should not be necessary for newer Grails versions)</li>
<li> the "searchable" property convention must be defined as per Grails Searchable plugin, to add any fields that should be indexed for searching</li>
</ul><p class="paragraph"/><h4> Controlling the editing of your content type</h4><p class="paragraph"/>To customize behaviour for the properties of the domain class, the "editors" closure property is used, like Grails constraints closure - but in this case how they are treated in the Weceem editor.<p class="paragraph"/>For each field of the content domain class you can define the order in which they appear in the editor - based on the order in which they are listed in the editors closure.<p class="paragraph"/>You can also set the editor used for each property. These have names like HtmlCode, ReadOnly, CssCode, GroovyCode etc. You can also define your own editors if the supplied editors are not suitable. See the section on customizing content editors.<p class="paragraph"/>Some properties are for internal use only, for those you can set hidden:true.<p class="paragraph"/>Finally, you can push your properties into the "Extras" editor group that is displayed separately by setting "group" to "extra":<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> editors = &#123;
    isbn(editor:'ISBNEditor')
    genre(editor:'GenrePopup', group:'extra')</pre></div><p class="paragraph"/><h4> Displaying content as text or HTML</h4><p class="paragraph"/>For various reasons such as search results and versioning, Weceem needs to be able to get some kind of representation of your custom content as both plain text and HTML. If your needs are different from the defaults, you can override the methods for getContentAsText and getContentAsHTML.<p class="paragraph"/>The default behaviour is:<p class="paragraph"/><div class="code"><pre>/&#42;&#42;  &#42; Must be overriden by content types that can represent their content as text.
 &#42; Used <span class="java&#45;keyword">for</span> search results and versioning
 &#42;/ <span class="java&#45;object">String</span> getContentAsText() &#123; <span class="java&#45;quote">""</span> &#125;
/&#42;&#42;
 &#42; Should be overriden by content types that can represent their content as HTML.
 &#42; Used <span class="java&#45;keyword">for</span> wcm:content tag (content rendering)
 &#42;/ <span class="java&#45;object">String</span> getContentAsHTML() &#123; contentAsText ? contentAsText.encodeAsHTML() : '' &#125;</pre></div><p class="paragraph"/>So as a minimum, override getContentAsText() - but if there is a reasonable HTML representation, e.g. for HTML, Wiki or other richly formatted content,  you should also implement getContentAsHTML().<p class="paragraph"/><h4> Defining mime type</h4><p class="paragraph"/>Weceem's content controller will ask the content for its MIME type when building the response. In many content types this is a constant value and is not persisted, but in types such as WcmContentFile this is persisted so that the type can be overridden by the user.<p class="paragraph"/>To return the correct MIME type, just implement the getter:<p class="paragraph"/><div class="code"><pre><span class="java&#45;object">String</span> getMimeType() &#123; <span class="java&#45;quote">"text/html"</span> &#125;</pre></div><p class="paragraph"/>This non-static value is read whenever the content is to be served. This means that you can determine it on a per-node basis, which is how the WcmContentFile type specifies the mime types of downloadable files.<p class="paragraph"/><h4> Customizing rendering of your content </h4><p class="paragraph"/>Weceem delegates rendering of content to the content node itself. If there is no rendering implementation provided, it will simply render the node as text to the client. This mechanism is used by the built in content types to render themselves appropriately. Some types render HTML decorated by a template, and others issue redirects.<p class="paragraph"/>There are two conventions that control the custom rendering of content:
<ul class="star">
<li>Static "standaloneContent" property is set to false if content type is not intended for direct rendering. This prevents node types used by other types from being rendered when their URI is requested - e.g. is the built-in template and widget types, which make no sense being rendered on their own.</li>
<li>Static "handleRequest" Closure property provides custom implementation of rendering if you require it.</li>
</ul><p class="paragraph"/>The handleRequest closure is executed so that it delegates to Weceem's content controller. This means you can use all the regular Grails dynamic controller methods and properties (render, redirect, response, request, session) as well as some custom methods to render Weceem content nodes using the normal GSP and templating mechanisms.<p class="paragraph"/>Here's an example of how WcmHTMLContent renders its regular HTML or GSP code :<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> handleRequest = &#123; content &#45;&#62;
    <span class="java&#45;keyword">if</span> (content.allowGSP) &#123;
        renderGSPContent(content)
    &#125; <span class="java&#45;keyword">else</span> &#123;
        renderContent(content)
    &#125;
&#125;</pre></div><p class="paragraph"/>This implementation calls WcmContentController's renderContent method if the content is HTML, which will render the content inside a Template if the node has one. Alternatively if the content is classed as GSP content, it calls the controller's renderGSPContent method which renders the content as GSP code, inside a template if one is found for the node.<p class="paragraph"/>Another example is the External Link type which redirects the browser to the target URL of the node :<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> handleRequest = &#123; content &#45;&#62;
   redirect(url:content.url)
&#125;</pre></div><p class="paragraph"/>This implementation uses the standard Grails "redirect" method to redirect to the URL specified in the content's "url" property.<p class="paragraph"/>The Template, Widget and HTML content nodes can use Weceem tags and other Grails tags to perform view rendering logic.<p class="paragraph"/><h4> Interacting with content events </h4><p class="paragraph"/>Content nodes can hook into common events, such as deletion and updates. To do this your content class needs to implement methods for any events it wants to support. None of these are mandatory, and you can implement only those you need. The available event methods are defined in 
<a href="https://fisheye.codehaus.org/browse/grails-plugins/grails-weceem/trunk/src/groovy/org/weceem/event/WeceemDomainEvents.groovy?r=HEAD" target="blank">WeceemDomainEvents.groovy</a><p class="paragraph"/>The event methods are:<p class="paragraph"/><div class="code"><pre><span class="java&#45;object">boolean</span> contentShouldBeCreated(WcmContent parentNodeOrNull)</pre></div><p class="paragraph"/>This method allows the content to veto whether or not it can be created. This is called on the newly populated but not saved content node, and is passed the parent node that it would be attached to, which can be null if it is root level content.<p class="paragraph"/><div class="code"><pre>void contentDidGetCreated()</pre></div><p class="paragraph"/>This is called after the content node has been created and saved.<p class="paragraph"/><div class="code"><pre><span class="java&#45;object">boolean</span> contentShouldBeDeleted()</pre></div><p class="paragraph"/>This allows the content type to veto whether or not the node can or should be deleted - e.g. it may not be possible to delete a content node if it has children.<p class="paragraph"/><div class="code"><pre>void contentWillBeDeleted()</pre></div><p class="paragraph"/>This event is triggered just before the node is deleted.<p class="paragraph"/><div class="code"><pre>void contentDidGetDeleted()</pre></div><p class="paragraph"/>This event is triggered immediately after the node is deleted.<p class="paragraph"/><div class="code"><pre>void contentDidChangeTitle(<span class="java&#45;object">String</span> previousTitle)</pre></div><p class="paragraph"/>This event is called when the title property of a node has changed.<p class="paragraph"/><div class="code"><pre>void contentDidGetUpdated()</pre></div><p class="paragraph"/>This event is triggered after a node has been edited and the new values saved.<p class="paragraph"/><div class="code"><pre><span class="java&#45;object">boolean</span> contentShouldMove(WcmContent targetParent)</pre></div><p class="paragraph"/>This event is called to allow it to veto being moved to parent nodes that are not compatible. Returning false will prevent the user moving the node (changing its parent).<p class="paragraph"/><div class="code"><pre>void contentDidMove()</pre></div><p class="paragraph"/>This is called after the content's parent has been changed and saved.<p class="paragraph"/><div class="code"><pre><span class="java&#45;object">boolean</span> contentShouldAcceptChildren()</pre></div><p class="paragraph"/>This event is called to find out if the current node can accept child nodes.<p class="paragraph"/><div class="code"><pre><span class="java&#45;object">boolean</span> contentShouldAcceptChild(WcmContent newChild)</pre></div><p class="paragraph"/>This event is called to find out if the current node can accept the new child node. There might be per-node reasons for vetoing new children.<p class="paragraph"/>You can also hook into many events outside of the domain classes themselves, using the Event Service.<p class="paragraph"/><h4> Customizing the icon shown in the repository</h4><p class="paragraph"/>You can supply an icon for your custom content types, that will be used in the admin UI of Weceem, e.g. in the repository view. To do this, define a static "icon" property which contains the arguments you would pass to <strong class="bold">Grails g:resource tag</strong> to create a link to the resource :<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> icon = &#91;
   plugin: <span class="java&#45;quote">"weceem"</span>,
   dir: <span class="java&#45;quote">"_weceem/images/weceem/content&#45;icons"</span>,
   file: <span class="java&#45;quote">"widget&#45;32.png"</span>
&#93;</pre></div><p class="paragraph"/>It is vital to include the "plugin" attribute and value if you are placing your custom content class in a plugin of your own.<p class="paragraph"/><h4> Content versioning</h4><p class="paragraph"/>In order to participate in Weceem's content versioning system, you need to add any properties you wish to have serialized to the getVersioningProperties() implementation of your class. This function returns a map of values that are stored in the content revision.<p class="paragraph"/>These are simple values that must be expressible as strings. By necessity you may refer to objects not available at the time the user views your revision, so all complex object references that need to be versioned should be coerced to some kind of text representation.<p class="paragraph"/>For a real example, here's the code from WcmHTMLContent :<p class="paragraph"/><div class="code"><pre>Map getVersioningProperties() &#123;
    def r = <span class="java&#45;keyword">super</span>.getVersioningProperties() + &#91;
        menuTitle:menuTitle,
        htmlTitle:htmlTitle,
        keywords:keywords,
        template:template?.ident() // A string representation of template object
    &#93; 
    <span class="java&#45;keyword">return</span> r
&#125;</pre></div><p class="paragraph"/>In almost all cases you will want to call the super method to ensure all inherited properties are correctly versioned.


<h2 id="2.CustomContentEditors">6.3 Custom content editors</h2>
As mentioned in the create custom content type section, you can specify what kind of editor is used for each property of content types. By following some simple procedure, you can also create your own new editors.<p class="paragraph"/>Weceem will locate the appropriate editor using the name of the type of the property, if a custom property editor name is not given.<p class="paragraph"/><h4> Content Editors</h4><p class="paragraph"/>Weceem has quite a few editors that are available to edit all the predefined content type properties.<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Editor Field Name</strong></th><th><strong class="bold">Description</strong></th></tr><tr class="table-odd"><td>String</td><td>for single-line strings</td></tr><tr class="table-even"><td>LongString</td><td>for multi-line strings</td></tr><tr class="table-odd"><td>Integer</td><td>for whole numbers</td></tr><tr class="table-even"><td>Boolean</td><td>for boolean fields</td></tr><tr class="table-odd"><td>Date</td><td>for dates, includes datepicker and HH and MM fields</td></tr><tr class="table-even"><td>Title</td><td>uses a larger font for editing the title</td></tr><tr class="table-odd"><td>Tags</td><td>UI for displaying and add/remove tags via ajax</td></tr><tr class="table-even"><td>ContentFileUpload</td><td>renders a file upload field or file information if already uploaded</td></tr><tr class="table-odd"><td>RichHTML</td><td>HTML editing with rich editor</td></tr><tr class="table-even"><td>HTMLContent</td><td>HTML content editor that checks allowGSP property on content and switches between RichHTML and HtmlCode as appropriate</td></tr><tr class="table-odd"><td>HtmlCode</td><td>Code editor with highlighting for HTML</td></tr><tr class="table-even"><td>JSCode</td><td>Code editor with highlighting for JavaScript</td></tr><tr class="table-odd"><td>GroovyCode</td><td>Code editor with highlighting for Groovy code</td></tr><tr class="table-even"><td>CSSCode</td><td>Code editor with highlighting for CSS code</td></tr><tr class="table-odd"><td>LanguageList</td><td>a language selection drop-down list</td></tr><tr class="table-even"><td>WcmScript</td><td>For selecting any WcmScript node in the current space</td></tr><tr class="table-odd"><td>WcmStatus</td><td>For selecting any WcmStatus instance</td></tr><tr class="table-even"><td>WcmTemplate</td><td>For selecting any WcmTemplate instance in the current space</td></tr><tr class="table-odd"><td>WcmSpace</td><td>For selecting a Space</td></tr><tr class="table-even"><td>ReadOnly</td><td>a text-only rendering of the value with no editing capability</td></tr><tr class="table-odd"><td>ReadOnlyURI</td><td>a text-only URI value, using URL encoding of restricted chars</td></tr><tr class="table-even"><td>ReadOnlyDate</td><td>a read-only display of a date</td></tr></table><p class="paragraph"/><h4> Writing your own content editor</h4><p class="paragraph"/>Creating a custom editor is simply a case of defining one or two Grails tags in the "wcm" namespace.<p class="paragraph"/>Editors are resolved by looking for a tag with the target editor name appended to "wcm:editorField". So for example a new editor for choosing a colour might be called Colour and the tag would be called "editorFieldColour" :<p class="paragraph"/><div class="code"><pre>class MyWeceemTagLib &#123;
    <span class="java&#45;keyword">static</span> namespace = <span class="java&#45;quote">"wcm"</span><p class="paragraph"/>def editorFieldColour = &#123; attrs &#45;&#62; 
          out &#60;&#60; someFancyColourPicker(pageScope.content&#91;attrs.property&#93;)
    &#125;
&#125;</pre></div><p class="paragraph"/>These tags are called with the following attributes:
<ul class="star">
<li>property - property name of the content object for which the tag should render a field</li>
</ul><p class="paragraph"/>Your tags can access the current content object being edited using :<p class="paragraph"/><div class="code"><pre>pageScope.content&#91;attrs.property&#93;</pre></div><p class="paragraph"/>In the above example,  you would not need to specify editor:'Colour' on your custom content classes if the property type is actually an instance of a Colour class.<p class="paragraph"/><strong class="bold">Note :</strong> Polymorphism is not yet supported in this scenario so only exact class matches will work.<p class="paragraph"/><h4> Providing resources needed by custom editors</h4><p class="paragraph"/>Some editors - e.g. the FCK and code editors used by Weceem, require JavaScript and CSS resources to be included in the &#60;head&#62; section of the editor page. To achieve this, Weceem looks for a tag with a name like "wcm:editorResourcesColour" where the type name is appended to "editorResources". This tag can output anything you like into the &#60;head&#62; section of the page:<p class="paragraph"/><div class="code"><pre>def editorResourcesTags = &#123; attrs &#45;&#62;
        out &#60;&#60; g.render(template:'/editors/tags_resources', plugin:'weceem', 
            model:&#91;name:attrs.property, value:pageScope.content&#91;attrs.property&#93;&#93;)
    &#125;</pre></div><p class="paragraph"/>Here, the Tags editor uses another GSP to output the more complex resource elements it requires, setting up JS code in the &#60;head&#62; section to bind add/remove buttons using jQuery.<p class="paragraph"/>


<h2 id="3.CustomRequestAndFormSubmissionWithGroovyScripts">6.4 Custom request/form submission with groovy scripts</h2>
Capture data from forms and perform an action, such as sending mail after submission of a contact form by writing some Groovy code that you store in the content repository. This happens dynamically and you don't need to redeploy your Weceem application or restart it.<p class="paragraph"/>Two content types work together in Weceem to enable you to write arbitrary server-side code. The Scripted Action node type is used to receive requests, and delegates the work to a Groovy Script node.<p class="paragraph"/>For example, to create a Contact form that sends mail to a known address, you could implement it like this :
<ol>
<li>Create a Groovy Script node in your repository, and paste into it the following code :</li>
</ol><p class="paragraph"/><div class="code"><pre>def args = &#91;
  recipients:'admin@yourserver.com',
  subject:'Message from website visitor'
&#93;
<span class="java&#45;keyword">try</span> &#123;
  sendMail &#123;
    to args.recipients
    <span class="java&#45;keyword">if</span> (args.ccRecipients) &#123;
      cc args.ccRecipients
    &#125;
    subject args.subject<p class="paragraph"/>    from params.senderAddress
    body params.message
  &#125;
  redirect(uri:params.success)
&#125; <span class="java&#45;keyword">catch</span> (Exception e) &#123;
  log.error <span class="java&#45;quote">"Can't send mail"</span>, e
  redirect(uri:params.error)
&#125;</pre></div><p class="paragraph"/>This code expects the Grails "mail" plugin to be installed (as it is by default in the Weceem application WAR file). This code is exactly what you would write if you were writing your own <a href="https://grails.org/doc/latest/guide/theWebLayer.html#6.1%20Controllers." target="blank">Grails controller action</a>  You can call redirect, render and other Grails controller methods as usual. The request parameters are in "params".<p class="paragraph"/><a href="https://grails.org/doc/latest/guide/theWebLayer.html#6.1%20Controllers" target="blank">WeceemDomainEvents.groovy</a><p class="paragraph"/>2. Now that you have a script to run, you need to create a Scripted Action node to respond to requests for a specific URI and run the script. When you do this, select the script you created in the "Script" field. The full repository URI of this Scripted Action content node is the URI that needs to be used in your HTML form's action attribute. You can create links to this action inside your own Widget or Template nodes using the wcm:createLink tag.<p class="paragraph"/>With the above example, the HTML form needs to supply fields "senderAddress" and "message". It will redirect the user to the value of the "success" parameter which will usually be a URI in your content repository created using the wcm:createLink tag.<p class="paragraph"/>You can write any Groovy code you like in the Groovy Script node. The possibilities are endless for example, you can call out to external web services, perform calculations, render complex results in alternative formats (e.g. JSON).<p class="paragraph"/>However, you can easily degrade the performance of your server by writing inefficient code in a Groovy Script that is executed frequently.<p class="paragraph"/>It is strongly recommended that you limit the users that can create Groovy Scripts using the Weceem Security Policy.


<h2 id="4.EmbeddingContent">6.5 Embedding content</h2>
In some custom applications you may want to embed some Weceem content within your own Grails GSP views. This is easily achieved for most situations using the new <strong class="bold">wcm:render</strong> tag as of release 1.1.<p class="paragraph"/>However, if you need to render content with more control over the process - e.g. using an artificial request/response to render content for use in emails, you can use the wcmRenderEngine bean.<p class="paragraph"/>This bean offers methods for rendering a specific content node.<p class="paragraph"/>You must typically pass in a request and response to use - given that most of Weceem functionality uses Grails tags and these require features of requests and responses - although you can usually also pass in your own controller instance if you have one.<p class="paragraph"/>See the source code for <a href="https://github.com/jCatalog/weceem-plugin/blob/master/src/groovy/org/weceem/content/RenderEngine.groovy" target="blank">RenderEngine on github</a> for more details.


<h2 id="5.ExportingAndImportingContent">6.6 Exporting and importing content</h2>
Each Weceem space (repository) can be individually exported and imported individually and is useful for backups or migrating content between servers or spaces.<p class="paragraph"/>For this :
<ol>
<li>Go to the Administration section</li>
<li>Select option - "Spaces"</li>
<li>Click  the Export or Import buttons</li>
<li>Select space when prompted.</li>
</ol><p class="paragraph"/>Use the default import/exporter - it is the native Weceem exporter.<p class="paragraph"/>The exported ZIP file will include all content nodes and uploaded files for that space. You can then import this ZIP into another Weceem instance, or to a different space in the same instance.<p class="paragraph"/><strong class="bold">Importing will replace any content in the space!</strong><p class="paragraph"/><strong class="bold">Note :</strong><p class="paragraph"/>Exported spaces will not include your user accounts or any custom WcmStatus nodes you created, as these are not Space-specific.



<h2 id="6.HookingIntoContentEvents">6.7 Hooking into content events</h2>
In custom Grails applications that use Weceem plugin you may need to perform actions when certain events occur on content.<p class="paragraph"/>To do this, register a listener with the WcmEventService and implement any of the event notification methods you require.<p class="paragraph"/>First, you inject the WcmEventService using Grails dependency injection, or obtain it via the Spring ApplicationContext, and then call the "addListener" method :<p class="paragraph"/><div class="code"><pre>class MyService <span class="java&#45;keyword">implements</span> InitializingBean &#123;
    def wcmEventService<p class="paragraph"/>    void afterPropertiesSet() &#123;
        wcmEventService.addListener(<span class="java&#45;keyword">this</span>)
    &#125;<p class="paragraph"/>    void contentDidGetUpdated(WcmContent node) &#123;
        log.info <span class="java&#45;quote">"Look! Content $&#123;node.title&#125; was updated"</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>The list of available events is defined in the WeceemEvents class, which uses an optional event callback method mechanism -<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> org.weceem.event<p class="paragraph"/><span class="java&#45;keyword">import</span> org.weceem.content.WcmContent<p class="paragraph"/>class WeceemEvents &#123;
    <span class="java&#45;keyword">static</span> events = &#123;
        /&#42; Called just before saving the node &#42;/
        contentWillBeCreated &#123; WcmContent contentNode, WcmContent parentNode &#45;&#62; &#125;
        /&#42; Called after a <span class="java&#45;keyword">new</span> node has been created &#42;/
        contentDidGetCreated &#123; WcmContent node &#45;&#62; &#125;<p class="paragraph"/>        /&#42; Called before a node is deleted &#42;/
        contentWillBeDeleted &#123; WcmContent node &#45;&#62; &#125;
        /&#42; Called after a node is deleted &#42;/
        contentDidGetDeleted &#123; WcmContent node &#45;&#62; &#125;<p class="paragraph"/>        /&#42; Called after a <span class="java&#45;keyword">new</span> node is updated &#42;/
        contentDidGetUpdated &#123; WcmContent node &#45;&#62; &#125;<p class="paragraph"/>        /&#42; Called after a <span class="java&#45;keyword">new</span> node is moved to a <span class="java&#45;keyword">new</span> parent &#42;/
        contentDidMove &#123; WcmContent node, <span class="java&#45;object">String</span> previousURL, WcmContent previousParent &#45;&#62; &#125;
    &#125;<p class="paragraph"/>    <span class="java&#45;keyword">static</span> &#123;
        EventManager.define(WeceemEvents)
    &#125;
&#125;</pre></div><p class="paragraph"/>Implement the methods you need, using the signature defined in the WeceemEvents class.<p class="paragraph"/>There is a separate event interface called WeceemDomainEvents (given below) for developers that supply custom content types and for this you do not need to register as a lister - they are called as part of the regular lifecycle.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> org.weceem.event<p class="paragraph"/><span class="java&#45;keyword">import</span> org.weceem.content.WcmContent<p class="paragraph"/>class WeceemDomainEvents &#123;
    <span class="java&#45;keyword">static</span> events = &#123;
        /&#42; Called before a <span class="java&#45;keyword">new</span> node is created. Return <span class="java&#45;keyword">true</span> to allow the creation &#42;/
        contentShouldBeCreated &#123; WcmContent parentConent &#45;&#62; &#125;
        /&#42; Called just before saving the node &#42;/
        contentWillBeCreated &#123; WcmContent parentConent &#45;&#62; &#125;
        /&#42; Called after a node has been created, so that it can intialize anything that depends on it &#42;/
        contentDidGetCreated()<p class="paragraph"/>
        /&#42; Called to see <span class="java&#45;keyword">if</span> a node can be deleted. Return <span class="java&#45;keyword">true</span> to permit the deletion &#42;/
        contentShouldBeDeleted()
        /&#42; Called before a node is deleted. &#42;/
        contentWillBeDeleted()
        /&#42; Called after a node is deleted. &#42;/
        contentDidGetDeleted()<p class="paragraph"/>        /&#42; Called after a node's title has changed (edited). &#42;/
        contentDidChangeTitle &#123; <span class="java&#45;object">String</span> previousTitle &#45;&#62; &#125;
        /&#42; Called after a node is updated (edited). &#42;/
        contentDidGetUpdated()<p class="paragraph"/>        /&#42; Called before a node is moved to a <span class="java&#45;keyword">new</span> parent. Return <span class="java&#45;keyword">true</span> to permit the move. Parent may be <span class="java&#45;keyword">null</span> &#42;/
        contentShouldMove &#123; WcmContent newParent &#45;&#62; &#125;
        /&#42; Called after a node is moved to a <span class="java&#45;keyword">new</span> parent. &#42;/
        contentDidMove &#123; <span class="java&#45;object">String</span> previousURL, WcmContent previousParent &#45;&#62; &#125;<p class="paragraph"/>        /&#42; Called to establish whether <span class="java&#45;keyword">this</span> node can have children. Return <span class="java&#45;keyword">true</span> to permit addition of children &#42;/
        contentShouldAcceptChildren()
        /&#42; Called before a node is moved to become a child of <span class="java&#45;keyword">this</span> node. Return <span class="java&#45;keyword">true</span> to permit addition of the <span class="java&#45;keyword">new</span> child &#42;/
        contentShouldAcceptChild &#123; WcmContent possibleChild &#45;&#62; &#125;
    &#125;<p class="paragraph"/>    <span class="java&#45;keyword">static</span> &#123;
        EventManager.define(WeceemDomainEvents)
    &#125;
&#125;</pre></div>


<h2 id="7.PageRendering">6.8 Page rendering</h2>
When a request is made to Weceem, it goes through a number of steps to produce the final content.
<ol>
<li> Weceem first locates the content at the URI path specified in the request</li>
<li> Once located, it checks if content can be rendered. Content which is not "standalone" and used by other content cannot be rendered directly (e.g. Templates cannot be rendered directly).</li>
<li> Next, it checks to see if the content implements rendering itself. If it does, it will call the content's handleRequest method to perform the rendering of the response.</li>
<li> If there is no handleRequest method, Weceem will look for a "template" property on the content object and if it finds one, will ask that template to render the content.</li>
</ol><p class="paragraph"/>Different content types may implement handleRequest differently - e.g. HTML Content first checks if the content is set to allow GSP tags to execute. If they are, it will execute the page and capture the output. The content is then passed to the template (if any) and returned to the client.<p class="paragraph"/><strong class="bold">Note :</strong> If the content supports templates and a template is not set,  Weceem will look up the content tree to see if any ancestors specify a template and will use the first one it finds.<p class="paragraph"/>In this most common case, the HTML and Template will work together and render one or more Widget nodes using &#60;wcm:widget&#62; to render common page elements like the header and footer sections.<p class="paragraph"/>Other types such as External Link will use handleRequest to issue a redirect to the browser.<p class="paragraph"/><h4> Default document handling</h4><p class="paragraph"/>Weceem supports httpd-style request URLs that end in /,  it will automatically check for a child node of the URI, with one of the default names ("index.html" or "index"), much like a regular webserver.


<h2 id="8.IntegratingTheAuthenticationAndAuthorisationSystem">6.9 Integrating the  authentication and authorisation system</h2>
The Weceem plugin neither provides an authentication mechanism nor depends on authentication plugins. Just wire-in whichever authentication system you want to use - e.g.  the Weceem CMS Application wires up the Weceem plugin to the Spring Security plugin for authentication and provides a simple user management UI as part of the Weceem Admin.<p class="paragraph"/><strong class="bold">Customizing Authentication</strong><p class="paragraph"/>The WcmSecurityService class has simple methods on it that the CMS uses to get information about the current logged-in user. To customize this, just replace or modify the delegate property on the service - e.g. to plug in Acegi (note that Spring Security replaces Acegi - see below for an off the shelf solution), you would place code like this in the BootStrap of your application :<p class="paragraph"/><div class="code"><pre>def authenticateService = context.authenticateService<p class="paragraph"/>context.wcmSecurityService.securityDelegate = &#91;
	getUserName : &#123; &#45;&#62;
		def princ = authenticateService.principal()
		<span class="java&#45;keyword">if</span> (princ <span class="java&#45;keyword">instanceof</span> <span class="java&#45;object">String</span>) &#123;
			<span class="java&#45;keyword">return</span> <span class="java&#45;keyword">null</span>
		&#125; <span class="java&#45;keyword">else</span> &#123;
			<span class="java&#45;keyword">return</span> authenticateService.principal()?.username
		&#125;
	&#125;,
	getUserEmail : &#123; &#45;&#62;
		def princ = authenticateService.principal()
		<span class="java&#45;keyword">if</span> (princ <span class="java&#45;keyword">instanceof</span> <span class="java&#45;object">String</span>) &#123;
			<span class="java&#45;keyword">return</span> <span class="java&#45;keyword">null</span>
		&#125; <span class="java&#45;keyword">else</span> &#123;
			<span class="java&#45;keyword">return</span> authenticateService.principal()?.email
		&#125;
	&#125;
        getUserRoles : &#123; &#45;&#62; 
		authenticateService.userDomain()?.roleAuthorities ?: &#91;'ROLE_GUEST'&#93; 
	&#125;,
        getUserPrincipal : &#123; &#45;&#62; 
		authenticateService.principal()
	&#125;
&#93;</pre></div><p class="paragraph"/><h4> Integration with Spring Security</h4><p class="paragraph"/>If you create your own application using Weceem plugin and wish to use the Grails Spring Security plugin, install the weceem-spring-security plugin to provide the bridge between Weceem and your application's Spring Security authentication/authorization scheme.<p class="paragraph"/>When you use this plugin there is no need to write your own UserDetailsService for the Spring Security plugin.<p class="paragraph"/>To do this, after installing the plugin you simply have to specify some configuration to tell the plugin how to map from your Spring Security domain classes, and the plugin will make this information available to Weceem :<p class="paragraph"/><div class="code"><pre>weceem.springsecurity.details.mapper = &#123; &#45;&#62;
    &#91; // Stuff required by weceem spring sec
        username: username,
        password: password,
        enabled: enabled,
        authorities: authorities,
        // optional stuff we add
        email: email,
        description: description,
        firstName: firstName,
        lastName: lastName,
        id: id
    &#93;
&#125;</pre></div><p class="paragraph"/>This closure must return a map of data used by Spring Security to store the information about your domain class. The "it" passed to the closure is the domain class instance, so the above is returning a map with values copied from the domain class.<p class="paragraph"/><strong class="bold">Note :</strong> Only information required by Weceem is the username, password, enabled and authorities. Everything else is optional and only used by your application if you code it to do so.<p class="paragraph"/>The application remains responsible for defining the domain classes and performing the relevant Spring Security configuration to protect your URIs.<p class="paragraph"/>


<h2 id="9.StylingWithTemplates">6.10 Styling With Templates</h2>
Templates are content nodes used to set page layouts on your site. Certain content types such as HTML and Blog, support setting a template when creating or editing nodes. If a template is not set, it is inherited from the content's ancestors.<p class="paragraph"/>Typically the template will include the head and body tags, pull in the CSS and other resources required, and provide some common layout elements.<p class="paragraph"/>They use standard Grails tags and Weceem tags to render content within the body of the page, as well as meta data about the current page e.g. dynamic titles.<p class="paragraph"/>Here's a simple example that renders a dynamic title and renders the content of the current node.<p class="paragraph"/><div class="code"><pre>&#60;html&#62;
  &#60;head&#62;
    &#60;title&#62;$&#123;page.title.encodeAsHTML()&#125;&#60;/title&#62;
  &#60;/head&#62;
  &#60;body&#62;
    &#60;div id=<span class="java&#45;quote">"content"</span>&#62;
      &#60;wcm:content/&#62;
    &#60;/div&#62;
  &#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>The <code>&#60;wcm:content/&#62;</code> tag is used to render the content of the page the user requested. Its important to remember that your Template is not actually requested by the user by URI - it is simply used to decorate the content the user requested.<p class="paragraph"/>You might add a news panel to this layout, by using the <code>&#60;wcm:widget&#62;</code> tag to render a reusable block that iterates over children of the "News" node to list the titles of articles and links to them.<p class="paragraph"/><p class="paragraph"/>

                    </div>
                </td>
                <td id="col2">
            <div class="local clearfix">
                <div class="local-title">
                    <a href="../guide/index.html" target="mainFrame">Quick Reference</a>
                    <span class="toggle">(<a href="#" onclick="localToggle(); return false;">hide</a>)</span>
                </div>
                <div class="menu">
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">Domain</h1><div class="menu-sub">
                        
                        
                        <div class="menu-item"><a href="../ref/Domain/attach.html">attach</a>
                        </div>
                        
                        </div>
                    </div>
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">Tags</h1><div class="menu-sub">
                        
                        
                        <div class="menu-item"><a href="../ref/Tags/ancestorOfType.html">ancestorOfType</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/archiveList.html">archiveList</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/breadcrumb.html">breadcrumb</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/cache.html">cache</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/content.html">content</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/contentIconURL.html">contentIconURL</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/countChildren.html">countChildren</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/createFeedLink.html">createFeedLink</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/createLink.html">createLink</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/createSearchLink.html">createSearchLink</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/dataFeed.html">dataFeed</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/date.html">date</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/eachChild.html">eachChild</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/eachComment.html">eachComment</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/eachContent.html">eachContent</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/eachParent.html">eachParent</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/eachSibling.html">eachSibling</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/feedLink.html">feedLink</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/find.html">find</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/findNode.html">findNode</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/htmlToText.html">htmlToText</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/ifContentIs.html">ifContentIs</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/ifContentIsNot.html">ifContentIsNot</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/ifUserCanEdit.html">ifUserCanEdit</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/ifUserCanView.html">ifUserCanView</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/join.html">join</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/link.html">link</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/loggedInEmail.html">loggedInEmail</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/loggedInUserName.html">loggedInUserName</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/menu.html">menu</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/monthNames.html">monthNames</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/render.html">render</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/renderContentItemIcon.html">renderContentItemIcon</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/resource.html">resource</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/search.html">search</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/searchLink.html">searchLink</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/space.html">space</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/submitContentForm.html">submitContentForm</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/submitContentLink.html">submitContentLink</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/summarize.html">summarize</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/uiMessage.html">uiMessage</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/userInfo.html">userInfo</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/widget.html">widget</a>
                        </div>
                        
                        </div>
                    </div>
                    
                </div>
            </div>
        </td>
            </tr>
        </table>

        <div id="footer">
            jCatalog Software AG
            
        </div>



<script type="text/javascript" src="../js/docs.js"></script>

    </body>
</html>
