<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
    <head>
        <title>Weceem CMS 1.2</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen, print" title="Style" charset="utf-8" />
        <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8" />
    <script type="text/javascript">
function addJsClass(el) {
    var classes = document.body.className.split(" ");
    classes.push("js");
    document.body.className = classes.join(" ");
}
    </script>
    </head>

    <body class="body" onload="addJsClass();">
        <div id="navigation">
            <ul>
                <li>
                    <div id="nav-summary" onmouseover="toggleNavSummary(false)" onmouseout="toggleNavSummary(true)">
                        <a href="../guide/index.html" class="button">Table of contents</a>
                        <div id="nav-summary-childs" style="display:none;">
                            
                            <div class="toc-item" style="margin-left:0"><a href="#1.Introduction"><strong>1</strong><span>Introduction</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#2.ConfigurationAndInstallation"><strong>2</strong><span>Configuration and installation</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#3.GeneralBehaviourAndConcepts"><strong>3</strong><span>General behaviour and concepts</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#4.WeceemSecuritPolicy"><strong>4</strong><span>Weceem security policy</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#customization"><strong>5</strong><span>Customization</span></a></div>
                            
                        </div>
                    </div>
                </li>
                <li class="separator selected">
                    <a id="ref-button" onclick="localToggle(); return false;" href="#">Quick Reference</a>
                </li>
            </ul>
        </div>
        <div id="header">
            <div class="images clearfix">
                
                
            </div>
            <p>Weceem CMS is a free, open source content management system.</p>
        </div>


        <table id="colset" border="0" cellpadding="0" cellspacing="0">
            <tr>
                <td id="col1">
                    <div id="main" class="corner-all">

                        <span id='toggle-col1' class="toggle">(<a href="#" onclick="localToggle(); return false;">Quick Reference</a>)</span>

                        <div class="project">
                            <h1>Weceem CMS - Reference Documentation</h1>
                            <p><strong>Authors:</strong> jCatalog AG</p>
                            <p><strong>Version:</strong> 1.2</p>
                            
                        </div>

                        
                        <div id="table-of-content">
                            <h2>Table of Contents</h2>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#1.Introduction"><strong>1</strong><span>Introduction</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#2.ConfigurationAndInstallation"><strong>2</strong><span>Configuration and installation</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#3.GeneralBehaviourAndConcepts"><strong>3</strong><span>General behaviour and concepts</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#4.WeceemSecuritPolicy"><strong>4</strong><span>Weceem security policy</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#customization"><strong>5</strong><span>Customization</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#0.HookingIntoTheAdminInterface"><strong>5.1</strong><span>Hooking into the Admin interface</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#1.CreateCustomContentTypes"><strong>5.2</strong><span>Create custom content types</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#2.CustomContentEditors"><strong>5.3</strong><span>Custom content editors</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#3.CustomRequestAndFormSubmissionWithGroovyScripts"><strong>5.4</strong><span>Custom request/form submission with groovy scripts</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#4.EmbeddingContent"><strong>5.5</strong><span>Embedding content</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#5.ExportingAndImportingContent"><strong>5.6</strong><span>Exporting and importing content</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#6.HookingIntoContentEvents"><strong>5.7</strong><span>Hooking into content events</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#7.PageRendering"><strong>5.8</strong><span>Page rendering</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#8.IntegratingTheAuthenticationAndAuthorisationSystem"><strong>5.9</strong><span>Integrating the  authenticationand authorisation system</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#9.StylingWithTemplates"><strong>5.10</strong><span>Styling With Templates</span></a></div>
                            
                            <div style="clear:both" ></div>
                        </div>
                        
                        

<h1 id="1.Introduction">1 Introduction</h1>
<h3> Weceem CMS Grails Plugin</h3><p class="paragraph"/>Weceem is an open source Content Management System. It is written in Groovy and Grails and leverages the Grails infrastructure to a build customized CMS inside the Grails application.<p class="paragraph"/>It can be used to manage content, and create desired content types for custom functionality which can be integrated with existing systems.<p class="paragraph"/>With the Weceem plugin you can host corporate websites, simple blogs, search the site, SEO or build your own applications. You can define your own content types that add custom functionality or integrate tightly with existing systems you have.<p class="paragraph"/>There are numerous customization points that allow you to tailor the security mechanisms, administration skin, URL paths, scope for custom data types and server-side scripting using Groovy. It is built from the ground up to be embeddable as well as a standalone application.<p class="paragraph"/>The plugin supports multiple content repositories. Each repository is called a "Space" and represents a website that you maintain.<p class="paragraph"/><strong class="bold">Spaces</strong> are used to map and track content exchanges.  They can have multiple access rights defined in the Weceem security policy, hence one user can have permission or rights for different spaces.<p class="paragraph"/><strong class="bold">Content</strong> is created for the visitors of your website. Different types of content can be created and arranged in any desired structure within a Space<p class="paragraph"/>All you need for Weceem is an SQL database for storing content, a Java servlet container like Tomcat or Jetty to run.<p class="paragraph"/>Weceem's content is stored in a SQL database and not in files on the server filesystem. Uploaded file content is stored on the server filesystem and information about the file stored in the SQL database.<p class="paragraph"/>Current version of Weceem plugin is compatible with Grails 2.3<p class="paragraph"/><strong class="bold">Feature Highlights</strong>
<ul class="star">
<li>WYSIWYG Editor</li>
<li>Hierarchical content repository</li>
<li>Blogs</li>
<li>Full-text search</li>
<li>Form submissions</li>
<li>Templates with inheritance</li>
<li>Reusable widgets</li>
<li>Multiple-language support</li>
<li>Tagging</li>
<li>Auto-publish and auto-unpublish by date</li>
<li>Spaces: manage many sites in a single Weceem instance with per-space permissions</li>
<li>Content types include: HTML, Folder, JavaScript, CSS, Files, Blog, Comment, External Link, Groovy Scripts and Actions</li>
<li>Extensible using Java, Groovy and Grails</li>
<li>No design or SEO restrictions</li>
</ul><p class="paragraph"/>


<h1 id="2.ConfigurationAndInstallation">2 Configuration and installation</h1>
<h3> Installation</h3><p class="paragraph"/>Weceem is available either as a standalone Java web application (.war file) for deployment to standard Java server environments, or as a plugin for the <a href="http://grails.org/" target="blank">Grails application framework</a>.<p class="paragraph"/><h4> Requirements</h4><p class="paragraph"/>Deploying Weceem CMS requires:
<ul class="star">
<li> Java 6 or higher</li>
<li> A supported SQL server e.g. MySQL or Postgres</li>
<li> A recommended 500MB RAM allocated to the Java VM</li>
<li> A writeable filesystem folder for storing Lucene full-text search indexes</li>
</ul><p class="paragraph"/>You don't need to install or have any understanding of Grails to use Weceem, but if you want to develop a custom application that uses Weceem, you will also need to install Grails.<p class="paragraph"/><h4>Upgrading all Weceem installations</h4><p class="paragraph"/>Prior to installing a new version of Weceem, always export each of your spaces to ensure you have a backup. Additionally, ensure your database and uploaded files (e.g. WeceemFiles/) folder are backed up.<p class="paragraph"/><h4>Installing Weceem Plugin into the application</h4><p class="paragraph"/>To install the Weceem plugin, the dependency must be added into grails-app/conf/BuildConfig.groovy file in Grails application.
<div class="code"><pre>compile ':weceem:1.2&#45;SNAPSHOT'</pre></div><p class="paragraph"/>The plugin should function with Grails versions 2.1 and higher.<p class="paragraph"/>Once the plugin is installed into the application, a few Grails configuration changes may be required to make the CMS work in your application. These options are required for Weceem to operate correctly inside the application.<p class="paragraph"/><strong class="bold">Note:</strong> When upgrading from an earlier version of the Weceem plugin, you may need to manually uninstall some older Grails plugins, if your new release of Grails does not do it automatically.<p class="paragraph"/><strong class="bold">Warning!</strong> Weceem plugin uses Searchable plugin (version 0.6.6), it requires additional maven repository  <em class="italic">"http://repo.grails.org/grails/core"</em>  for getting
dependencies. Do not forget to configure:<p class="paragraph"/><div class="code"><pre>repositories &#123;
             &#8230;
             mavenRepo <span class="java&#45;quote">"http://repo.grails.org/grails/core"</span><p class="paragraph"/>         &#125;</pre></div><p class="paragraph"/><h3> Configuration</h3><p class="paragraph"/>Once the plugin is installed, there may be some Grails configurations that need to be changed to make the CMS work in the application. These options are required for Weceem to operate correctly within the application.<p class="paragraph"/>Configuration of Weceem is primarily through Grails configuration settings. In Weceem application these will come from a properties file that could be configured via system property <div class="code"><pre>weceem.config.location</pre></div> specified in the command line. But in the custom Grails application confuguration is typically loaded from Config.groovy.<p class="paragraph"/>There are several configuration options that allow you to customize how it behaves and looks.<p class="paragraph"/><h4> Allowing file extensions</h4><p class="paragraph"/>By default, Grails applications have content negotiation enabled based on file extensions in the URI, and this file extension is then removed from the URI. For the CMS to function correctly with content URIs like "common.css" and "jquery.js", you need to turn this off. To do so, change your application's Config.groovy to :<p class="paragraph"/><div class="code"><pre>grails.mime.file.extensions = <span class="java&#45;keyword">false</span></pre></div><p class="paragraph"/><h4> Default codec usage</h4><p class="paragraph"/>By default, Grails applications are configured to use value 'html' - legacy setting for codec used to encode data with ${} . But Weceem plugin requires such data without encoding.<p class="paragraph"/><div class="code"><pre>grails.views.<span class="java&#45;keyword">default</span>.codec=<span class="java&#45;quote">"none"</span></pre></div><p class="paragraph"/><h4> URL mappings and Weceem</h4><p class="paragraph"/>To replicate the behaviour of the binary Weceem Application WAR that can serve content from the "/" URI of your application, you must ensure the default URL Grails mapping for "/" in your application is removed. You will also probably benefit from removing the generic "$controller/$action?/$id?" mapping which can cause confusion.<p class="paragraph"/>You can namespace all Weceem controllers using configuration options to prefix all URIs that Weceem uses.<p class="paragraph"/><h4>Setting URL prefix for all content served by Weceem</h4><p class="paragraph"/>Weceem by default maps all created content into the "root" URI of the application. URLs are formed by "/{space URI alias}/${document URI alias path....}". Having a space with a blank alias URI, allows you to map content into the root URI.  To achieve this Weceem has to be rather promiscuous with its URI mapping.<p class="paragraph"/>If you would like your own controllers to be accessible with your own Grails URL mappings, you can prefix all content URIs by setting a single Config.groovy setting:<p class="paragraph"/><div class="code"><pre>weceem.content.prefix = 'content'</pre></div><p class="paragraph"/>With this, all Weceem content will be accessed under "/content/" - i.e.  http://localhost:8080/content/About<p class="paragraph"/><h4>Setting URL prefix for non-content Weceem controllers</h4><p class="paragraph"/>Weceem has its own non-content controllers that provide publicly-accessible support functionality such as the search, archive and visitor content submission controllers. If there are name conflicts with your own controllers, prefix these URIs with the following Config.groovy setting:<p class="paragraph"/><div class="code"><pre>weceem.tools.prefix = 'wcm&#45;tools'</pre></div><p class="paragraph"/>This will then ensure that all the Weceem tool controllers are accessed like this <code>http://localhost:8080/wcm-tools/search</code><p class="paragraph"/><h4>Setting URL prefix for Weceem administration UI</h4><p class="paragraph"/>The Weceem repository and administration UIs may also clash with your URI conventions, or you may have your own "admin" controller that you want at "/admin". For this, you can just change the prefix for the Weceem Admin controllers by adding the following to Config.groovy:<p class="paragraph"/><div class="code"><pre>weceem.admin.prefix = 'wcm&#45;admin'</pre></div><p class="paragraph"/>The standard Weceem admin interfaces under http://localhost:8080/wcm-admin/<p class="paragraph"/><h4> Defining available default Space templates</h4><p class="paragraph"/>You must tell Weceem what default content spaces are available to users or your code. There are two default spaces provided by the plugin but usually your application will want to specify alternative defaults so that it "boots" with your own content in it.<p class="paragraph"/><h4> Setting the location of uploaded files</h4><p class="paragraph"/>Weceem, by default, will store files uploaded by you (e.g. images, CSS and so on) to a folder inside the application's folder on the server. However, during an application upgrade, this becomes inconvenient because the files will often need to be manually duplicated in the new location on the server.<p class="paragraph"/>Since 1.0-M1 you can set the location of the upload folder or URL:<p class="paragraph"/><div class="code"><pre>// Tell weceem to use a specific path /<span class="java&#45;keyword">var</span>/weceem/uploads
/<span class="java&#45;keyword">var</span>/weceem/uploads weceem.upload.dir = 'file:///<span class="java&#45;keyword">var</span>/weceem/uploads'<p class="paragraph"/>// or tell weceem to keep it in the application folder, but with a <span class="java&#45;keyword">new</span> URL
weceem.upload.dir = '/weceem_uploads/'</pre></div><p class="paragraph"/>Weceem auto-senses file URLs in the value and uses that location if it is a file URL. If it is not a file URL, then it assumes it is a new URL path and uses it when serving the files.<p class="paragraph"/>Weceem will still store the files in <code>&#60;app-dir&#62;/WeceemFiles</code>, if a value is not specified for this config variable. These will be served from <code>http://&#60;yourhost&#62;/&#60;yourapppath&#62;/uploads/</code><p class="paragraph"/><h4>Customizing user profile and logout</h4><p class="paragraph"/>When integrating your own user authentication/authorization system, you will want the Profile and Log Out links in Weceem admin to point to the relevant functions in your application.  Specify a map of arguments that will be passed to the Grails <strong class="bold">g:link</strong> tag to create the links for these functions, with the following Config.groovy settings:<p class="paragraph"/><div class="code"><pre>weceem.profile.url = &#91;controller:'register', action:'edit'&#93; weceem.logout.url = &#91;controller:'logout'&#93;</pre></div><p class="paragraph"/>Controller/action etc can be anything you like. You could use any arguments accepted by the Grails linking tags here e.g: uri, url, params, mapping and so on.<p class="paragraph"/><h4>Customizing the look and feel of Weceem Admin</h4><p class="paragraph"/>For the Weceem Admin pages to fit in better with your application's own styling, you can specify a different layout GSP for it with this Config option:<p class="paragraph"/><div class="code"><pre>weceem.admin.layout=<span class="java&#45;quote">"mylayout"</span></pre></div><p class="paragraph"/>This stops Weceem from using the standard "weceemadmin" GSP layout and uses yours instead.<p class="paragraph"/><h4>Customizing page for 404 Server response</h4><p class="paragraph"/>For the HTTP 404 Server response, you can specify a different GSP page with this Config option:<p class="paragraph"/><div class="code"><pre>weceem.page404 = 'errorpage'</pre></div><p class="paragraph"/>By default, the page '404.gsp' from Weceem plugin is used.<p class="paragraph"/><h4>Controlling creation of the default space</h4><p class="paragraph"/>You can configure whether or not Weceem should create a default space at startup, as well as what templates are available to the user:<p class="paragraph"/><div class="code"><pre>// Turn off <span class="java&#45;keyword">default</span> space creation <span class="java&#45;keyword">if</span> no spaces found at startup weceem.create.<span class="java&#45;keyword">default</span>.space = <span class="java&#45;keyword">false</span><p class="paragraph"/>// Set the file: or classpath: URL of the <span class="java&#45;keyword">default</span> space zip <span class="java&#45;keyword">if</span> <span class="java&#45;keyword">default</span> creation is ON weceem.<span class="java&#45;keyword">default</span>.space.template = <span class="java&#45;quote">"file:/path/to/template.zip"</span></pre></div><p class="paragraph"/><h4>Changing the list of space templates available to users</h4><p class="paragraph"/>To change the list of space templates available to users when they create a new space, list them in your Config:<p class="paragraph"/><div class="code"><pre>// Set the list of available space templates when a user creates a <span class="java&#45;keyword">new</span> space
weceem.space.templates = &#91;
    <span class="java&#45;keyword">default</span>: <span class="java&#45;quote">"classpath:/org/weceem/resources/<span class="java&#45;keyword">default</span>&#45;space&#45;template.zip"</span>,
    basic:<span class="java&#45;quote">"classpath:/org/weceem/resources/basic&#45;space&#45;template.zip"</span>&#93;</pre></div><p class="paragraph"/>Space templates are regular Weceem export ZIPs, and can reside in the file system (file:) or classpath (classpath:)<p class="paragraph"/>Use this to hide the default Weceem spaces and restrict user access to the space templates. This list of space templates does not have to include the default space template, hence you can have a default initial space that is unavailable to the users.



<h1 id="3.GeneralBehaviourAndConcepts">3 General behaviour and concepts</h1>
<h3> Content Publishing Workflow</h3><p class="paragraph"/>A simple workflow mechanism is implemented in Weceem.<p class="paragraph"/>In Weceem, the workflow hinges on the Status of each content node. The following Status options are provided:
<ul class="star">
<li>Draft</li>
<li>Unmoderated</li>
<li>Reviewed</li>
<li>Approved</li>
<li>Published</li>
<li>Archived</li>
</ul><p class="paragraph"/>There is no UI for editing the list of statuses, but if you are a developer and wish to add new ones, bear in mind the rules for the workflow as set out here.<p class="paragraph"/>Each status has a numerical code - e.g. Draft is 100, Unmoderated - 150, Published - 400 etc. Each status also has a flag to indicate whether or not it is "public" content i.e. can be viewed by non-administrators. By default Published is the only status with this flag set.<p class="paragraph"/>All changes to status are made manually by repository users, unless the <strong class="bold">Publish From</strong> or <strong class="bold">Publish Until</strong> fields have values,<p class="paragraph"/>In the case of <strong class="bold">Publish From</strong>, once the date passes, the status of the content will change to the first status with "public content" flag switched on, which has a higher code number than the current status of the content. This offers scope for other statuses beyond the existing set, and migration upward through those states.<p class="paragraph"/>The one caveat here is that the <strong class="bold">Publish From</strong> mechanism will never change the status on content that is currently in the "Unmoderated" or "Archived" status used for visitor-submitted or expired content. If you need to change which status is used for "Unmoderated" or "Archived" content you can do this by setting the configuration variables to the numerical code values of the desired status <code>weceem.unmoderated.status</code> and <code>weceem.archived.status</code><p class="paragraph"/>With <strong class="bold">Publish Until</strong>, the status of any published content that has expired will be set to the "Archived" status or the status defined in the configuration variable <code>weceem.archived.status</code><p class="paragraph"/><h4> Page Variables</h4><p class="paragraph"/>Templates, Widgets and HTML Content (with allow GSP enabled) have access to a data model that includes several variables used to render information about the current page, user or space.<p class="paragraph"/><strong class="bold">Variable: page</strong><p class="paragraph"/>This object presents information about the current page of the web site. The page is constructed from a template and content, and is located using a unique URI.  This is not to be confused with the "active" content node.<p class="paragraph"/><strong class="bold">Properties</strong><p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Name</strong></th><th>Description</th></tr><tr class="table-odd"><td>URI</td><td>uri of this page relative to the current space</td></tr><tr class="table-even"><td>parentURI</td><td>uri of this page's content node's parent</td></tr><tr class="table-odd"><td>lineage</td><td>list of ancestor nodes, in top-down order</td></tr><tr class="table-even"><td>title</td><td>page title</td></tr><tr class="table-odd"><td>titleForHTML</td><td>page title for HTML title tag, including SEO keywords</td></tr><tr class="table-even"><td>titleForMenu</td><td>page title for rendering menus, usually a shorter version of the title</td></tr></table><p class="paragraph"/><strong class="bold">Variable: user</strong><p class="paragraph"/>This object presents information about the current user.<p class="paragraph"/><strong class="bold">Properties</strong><p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Name</strong></th><th><strong class="bold">Description</strong></th></tr><tr class="table-odd"><td>username</td><td>User's login name</td></tr><tr class="table-even"><td>firstName</td><td>User's first name</td></tr><tr class="table-odd"><td>lastName</td><td>User's last name</td></tr><tr class="table-even"><td>email</td><td>User's email address</td></tr></table><p class="paragraph"/><strong class="bold">Variable: node</strong><p class="paragraph"/>This object provides access to information about the primary content node of this page. The properties available will vary based on the content type.<p class="paragraph"/><strong class="bold">Properties</strong><p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Name</strong></th><th><strong class="bold">Description</strong></th></tr><tr class="table-odd"><td>title</td><td>content title</td></tr><tr class="table-even"><td>content</td><td>content text</td></tr><tr class="table-odd"><td>aliasURI</td><td>primary URI for this content node</td></tr><tr class="table-even"><td>language</td><td>language of this content, a Language object</td></tr><tr class="table-odd"><td>createdBy</td><td>name of the user who created the content</td></tr><tr class="table-even"><td>createdOn</td><td>date the content was originally created</td></tr><tr class="table-odd"><td>changedBy</td><td>username of the last user to edit the content</td></tr><tr class="table-even"><td>changedOn</td><td>date on which the content was last edited</td></tr><tr class="table-odd"><td>space</td><td>space (object) to which this content node belongs</td></tr></table><p class="paragraph"/>


<h1 id="4.WeceemSecuritPolicy">4 Weceem security policy</h1>
The Weceem security policy file is a Groovy script in your server filesystem, that lets you control who can access your content and what they can do with it.<p class="paragraph"/>The security policy uses information about the currently-logged in user's roles as supplied by the integration with your authentication system.<p class="paragraph"/>The security system gives you control over:
<ul class="star">
<li>spaces that users in different roles can access</li>
<li>URI paths in each space these users can access</li>
<li>permissions (admin, create, update, delete, view) the users have for these URI paths</li>
<li>the types of content nodes for which the users have these permissions</li>
</ul><p class="paragraph"/>So in combination, you can control how people interact with your site - like offering protected areas for known users, and allowing comments from site visitors on some content and not others.<p class="paragraph"/><h4>Setting a security policy</h4><p class="paragraph"/>The Weceem plugin automatically looks for a security policy - which is a Groovy script - using the following logic:
<ol>
<li>It looks to see if the Grails configuration variable "weceem.security.policy.path" has a value set by the Grails application's Config.groovy.</li>
<li>If so, it uses that as the file path. If that variable is not set, it will look for the system property "weceem.security.policy.path" and use that if set.</li>
<li>If neither are set, it will initialize with default permissions where ROLE_ADMIN can do anything, ROLE_USER can create/edit content, and ROLE_GUEST can only view.</li>
</ol><p class="paragraph"/><h4>How to write a Weceem security policy</h4><p class="paragraph"/>Weceem plugin does not predefine any security role names - role names are just strings that your authentication system associates with users. The Weceem application happens to use Acegi/Spring security and is coded to supply roles called ROLE_ADMIN, ROLE_USER and ROLE_GUEST, but you are not limited to using these names.<p class="paragraph"/>Here's an example policy :<p class="paragraph"/><div class="code"><pre>// The policy closure must be assigned to the policy variable
policy = &#123;<p class="paragraph"/>  // Here we define a role &#45; <span class="java&#45;keyword">this</span> can be anything your authentication
  // system provides, but with Weceem Application edition, ROLE_GUEST, ROLE_USER,
  // and ROLE_ADMIN are used.
  // Note also that Weceem automatically adds the user's login as a special role
  // eg. user <span class="java&#45;quote">"fred"</span> automatically has a role added called <span class="java&#45;quote">"USER_fred"</span> <span class="java&#45;keyword">for</span> easy per&#45;user
  // access control
  'ROLE_ADMIN' &#123;
    // We're defining permissions <span class="java&#45;keyword">for</span> any space so use '&#42;'. Alternatively
    // specify a list of space alias URIs eg: space 'internal', 'extranet' (no square brackets!)
    space '&#42;'<p class="paragraph"/>    // Control whether <span class="java&#45;keyword">this</span> role can access Weceem admin functions eg edit/create spaces
    admin <span class="java&#45;keyword">true</span><p class="paragraph"/>    // Control whether <span class="java&#45;keyword">this</span> role can create <span class="java&#45;keyword">new</span> content in <span class="java&#45;keyword">this</span> space
    create <span class="java&#45;keyword">true</span><p class="paragraph"/>    // Control whether <span class="java&#45;keyword">this</span> role can edit content in <span class="java&#45;keyword">this</span> space
    edit <span class="java&#45;keyword">true</span><p class="paragraph"/>    // Control whether <span class="java&#45;keyword">this</span> role can view content in <span class="java&#45;keyword">this</span> space
    view <span class="java&#45;keyword">true</span><p class="paragraph"/>    // Control whether <span class="java&#45;keyword">this</span> role can delete content in <span class="java&#45;keyword">this</span> space
    delete <span class="java&#45;keyword">true</span>
  &#125;<p class="paragraph"/>  'ROLE_USER' &#123;
    space '&#42;'
    admin <span class="java&#45;keyword">false</span>
    create <span class="java&#45;keyword">true</span>
    edit <span class="java&#45;keyword">true</span>
    view <span class="java&#45;keyword">true</span>
    delete <span class="java&#45;keyword">false</span>
  &#125;<p class="paragraph"/>  'ROLE_GUEST' &#123;
    space '&#42;'
    admin <span class="java&#45;keyword">false</span>
    create <span class="java&#45;keyword">false</span>
    edit <span class="java&#45;keyword">false</span>
    view <span class="java&#45;keyword">true</span>
    delete <span class="java&#45;keyword">false</span><p class="paragraph"/>    // Here we have URI&#45;specific access restriction
    // We prevent guests from viewing the extranet
    <span class="java&#45;quote">"customers/extranet"</span> &#123;
      view <span class="java&#45;keyword">false</span>
    &#125;<p class="paragraph"/>    <span class="java&#45;quote">"blog"</span> &#123;
      // Limit creation to comments on blog only
      create types:&#91;org.weceem.content.WcmComment&#93;
    &#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>Per-URI permissions can set the same permissions that can be set on the space, and these take precedence. The permissions defined for the space are used as a fallback if there is no matching per-URI permission defined for that role.<p class="paragraph"/>So you can set "view false" on the spaces but then open up parts of the URI with "view true", or the other way around - however you like.<p class="paragraph"/>To specify permissions for certain content types only - specify a list of types instead of true/false, as is the case in the example above that permits users with ROLE_GUEST to only create WcmComment nodes and even then, only under the /blog/ part of the site.<p class="paragraph"/>This "types" list is a list of content classes that must be available on the classpath.



<h1 id="customization">5 Customization</h1>
This section covers the internal details that can be used to customize Weceem within your application, create custom content types and other more technical subjects.


<h2 id="0.HookingIntoTheAdminInterface">5.1 Hooking into the Admin interface</h2>
<strong class="bold">Hooking into the Admin interface of Weceem</strong><p class="paragraph"/>Applications can add items to the Weceem "Administration" page by using the Navigation plugin that Weceem CMS uses, to add items to the navigation group "weceem.app.admin". The Weceem Application does this :<p class="paragraph"/><div class="code"><pre>class UserController &#123;
        def authenticateService<p class="paragraph"/>        <span class="java&#45;keyword">static</span> navigation = &#91;group: 'weceem.app.admin', action: 'list', title: 'users'&#93;
&#125;</pre></div><p class="paragraph"/>The navigation plugin uses this convention property to place the "list" action of the user controller into the "Administration" section of Weceem Admin.


<h2 id="1.CreateCustomContentTypes">5.2 Create custom content types</h2>
Weceem provides many content types as standard. Each content type has a specific purpose, with different fields in the editor.<p class="paragraph"/>Some content types are directly rendered when requested, others are used by other content nodes to compose the page seen by the user.<p class="paragraph"/>The standard content types available in Weceem are :
<ul class="star">
<li>Action - A server-side action that will execute the code in a Groovy Script node, for example to create new content nodes or send an email</li>
<li>Blog - The root node of a Blog, which has Blog Entry nodes as children</li>
<li>Blog Entry - An entry (child of) a Blog node</li>
<li>Comment - A comment on a content node. Any nodes can have comments attached or created.</li>
<li>External Link - A URL of another website. When this URI is rendered, it redirects to the external site</li>
<li>Folder - A folder for grouping together content nodes and creating URI hierarchy</li>
<li>Groovy Script - A piece of Groovy code to execute on the server, used by Action nodes</li>
<li>HTML - A piece of HTML which may contain GSP (Grails Server Page) tags</li>
<li>JavaScript - A piece of JavaScript source</li>
<li>Server File - A file uploaded to the Weceem repository and stored on the server filesystem, e.g. an image file</li>
<li>Server Directory - A directory on the server filesystem which contains Server File nodes</li>
<li>Stylesheet - A CSS style sheet</li>
<li>Template - A GSP template used to layout and decorate the current content node</li>
<li>Widget - A reusable GSP fragment for rendering sections of a page, e.g. a header/footer or a remote news feed.</li>
</ul><p class="paragraph"/><h4> Creating custom content types</h4><p class="paragraph"/>You can add new content types that will be editable by your users and displayed in the repository along with the standard content types.<p class="paragraph"/>These custom types can have full control over how a request is handled (e.g. issue a redirect, like WcmExternalLink does) or delegate to established rendering mechanisms within Weceem. You might have it call out to a PDF generator for example, or render some data using an alternative presentation technology e.g. wiki rendering or Freemarker. They can also specify how their properties should be edited in the repository, and hook into events.<p class="paragraph"/>To create a new content type, you just need to create a new Grails domain class that extends the WcmContent class and follow a few simple conventions. You can create a basic template for a new content type using the create-content-class script :<p class="paragraph"/><div class="code"><pre>grails create&#45;content&#45;class com.mycompany.Product</pre></div><p class="paragraph"/>This will create the domain class under grails-app/domain/, with some default placeholder code. Here is an of the contentions.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.weceem.util.ContentUtils
<span class="java&#45;keyword">import</span> org.weceem.content.WcmContent<p class="paragraph"/>class PressRelease <span class="java&#45;keyword">extends</span> WcmContent &#123;<p class="paragraph"/>    // Set to <span class="java&#45;keyword">false</span> <span class="java&#45;keyword">if</span> <span class="java&#45;keyword">this</span> content node should never actually be rendered
    // i.e. Groovy Script nodes cannot be rendered directly.
    <span class="java&#45;keyword">static</span> standaloneContent = <span class="java&#45;keyword">false</span><p class="paragraph"/>    <span class="java&#45;object">String</span> getMimeType() &#123; <span class="java&#45;quote">"text/html"</span> &#125;<p class="paragraph"/>    <span class="java&#45;object">String</span> content<p class="paragraph"/>    /&#42;&#42;
     &#42; Must be overriden by content types that can represent their content as text.
     &#42; Used <span class="java&#45;keyword">for</span> search results and versioning
     &#42;/
    <span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> getContentAsText() &#123; ContentUtils.htmlToText(content) &#125;<p class="paragraph"/>    /&#42;&#42;
     &#42; Should be overriden by content types that can represent their content as HTML.
     &#42; Used <span class="java&#45;keyword">for</span> wcm:content tag (content rendering)
     &#42;/
    <span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> getContentAsHTML() &#123; content &#125;<p class="paragraph"/>    <span class="java&#45;keyword">static</span> constraints = &#123;
        content(nullable: <span class="java&#45;keyword">false</span>, maxSize: 65536)
    &#125;<p class="paragraph"/>    <span class="java&#45;keyword">static</span> editors = &#123;
        content(editor:'HtmlCode')
    &#125;<p class="paragraph"/>    <span class="java&#45;keyword">static</span> transients = WcmContent.transients
&#125;</pre></div><p class="paragraph"/>It declares a new type which, when created, will immediately become editable in the repository when you run your application.  There are several conventions that apply, described in more detail below -<p class="paragraph"/><strong class="bold">Basic considerations</strong><p class="paragraph"/>Your descendent class has certain conventions it must honour for correct operation :
<ul class="minus">
<li> the Grails "transients" property must be populated with the sum of the superclass transients and any new transient properties you add (should not be necessary for newer Grails versions)</li>
<li> the "searchable" property convention must be defined as per Grails Searchable plugin, to add any fields that should be indexed for searching</li>
</ul><p class="paragraph"/><h4> Controlling the editing of your content type</h4><p class="paragraph"/>To customize behaviour for the properties of the domain class, the "editors" closure property is used, like Grails constraints closure - but in this case how they are treated in the Weceem editor.<p class="paragraph"/>For each field of the content domain class you can define the order in which they appear in the editor - based on the order in which they are listed in the editors closure.<p class="paragraph"/>You can also set the editor used for each property. These have names like HtmlCode, ReadOnly, CssCode, GroovyCode etc. You can also define your own editors if the supplied editors are not suitable. See the section on customizing content editors.<p class="paragraph"/>Some properties are for internal use only, for those you can set hidden:true.<p class="paragraph"/>Finally, you can push your properties into the "Extras" editor group that is displayed separately by setting "group" to "extra":<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> editors = &#123;
    isbn(editor:'ISBNEditor')
    genre(editor:'GenrePopup', group:'extra')</pre></div><p class="paragraph"/><h4> Displaying content as text or HTML</h4><p class="paragraph"/>For various reasons such as search results and versioning, Weceem needs to be able to get some kind of representation of your custom content as both plain text and HTML. If your needs are different from the defaults, you can override the methods for getContentAsText and getContentAsHTML.<p class="paragraph"/>The default behaviour is:<p class="paragraph"/><div class="code"><pre>/&#42;&#42;  &#42; Must be overriden by content types that can represent their content as text.
 &#42; Used <span class="java&#45;keyword">for</span> search results and versioning
 &#42;/ <span class="java&#45;object">String</span> getContentAsText() &#123; <span class="java&#45;quote">""</span> &#125;
/&#42;&#42;
 &#42; Should be overriden by content types that can represent their content as HTML.
 &#42; Used <span class="java&#45;keyword">for</span> wcm:content tag (content rendering)
 &#42;/ <span class="java&#45;object">String</span> getContentAsHTML() &#123; contentAsText ? contentAsText.encodeAsHTML() : '' &#125;</pre></div><p class="paragraph"/>So as a minimum, override getContentAsText() - but if there is a reasonable HTML representation, e.g. for HTML, Wiki or other richly formatted content,  you should also implement getContentAsHTML().<p class="paragraph"/><h4> Defining mime type</h4><p class="paragraph"/>Weceem's content controller will ask the content for its MIME type when building the response. In many content types this is a constant value and is not persisted, but in types such as WcmContentFile this is persisted so that the type can be overridden by the user.<p class="paragraph"/>To return the correct MIME type, just implement the getter:<p class="paragraph"/><div class="code"><pre><span class="java&#45;object">String</span> getMimeType() &#123; <span class="java&#45;quote">"text/html"</span> &#125;</pre></div><p class="paragraph"/>This non-static value is read whenever the content is to be served. This means that you can determine it on a per-node basis, which is how the WcmContentFile type specifies the mime types of downloadable files.<p class="paragraph"/><h4> Customizing rendering of your content </h4><p class="paragraph"/>Weceem delegates rendering of content to the content node itself. If there is no rendering implementation provided, it will simply render the node as text to the client. This mechanism is used by the built in content types to render themselves appropriately. Some types render HTML decorated by a template, and others issue redirects.<p class="paragraph"/>There are two conventions that control the custom rendering of content:
<ul class="star">
<li>Static "standaloneContent" property is set to false if content type is not intended for direct rendering. This prevents node types used by other types from being rendered when their URI is requested - e.g. is the built-in template and widget types, which make no sense being rendered on their own.</li>
<li>Static "handleRequest" Closure property provides custom implementation of rendering if you require it.</li>
</ul><p class="paragraph"/>The handleRequest closure is executed so that it delegates to Weceem's content controller. This means you can use all the regular Grails dynamic controller methods and properties (render, redirect, response, request, session) as well as some custom methods to render Weceem content nodes using the normal GSP and templating mechanisms.<p class="paragraph"/>Here's an example of how WcmHTMLContent renders its regular HTML or GSP code :<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> handleRequest = &#123; content &#45;&#62;
    <span class="java&#45;keyword">if</span> (content.allowGSP) &#123;
        renderGSPContent(content)
    &#125; <span class="java&#45;keyword">else</span> &#123;
        renderContent(content)
    &#125;
&#125;</pre></div><p class="paragraph"/>This implementation calls WcmContentController's renderContent method if the content is HTML, which will render the content inside a Template if the node has one. Alternatively if the content is classed as GSP content, it calls the controller's renderGSPContent method which renders the content as GSP code, inside a template if one is found for the node.<p class="paragraph"/>Another example is the External Link type which redirects the browser to the target URL of the node :<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> handleRequest = &#123; content &#45;&#62;
   redirect(url:content.url)
&#125;</pre></div><p class="paragraph"/>This implementation uses the standard Grails "redirect" method to redirect to the URL specified in the content's "url" property.<p class="paragraph"/>The Template, Widget and HTML content nodes can use Weceem tags and other Grails tags to perform view rendering logic.<p class="paragraph"/><h4> Interacting with content events </h4><p class="paragraph"/>Content nodes can hook into common events, such as deletion and updates. To do this your content class needs to implement methods for any events it wants to support. None of these are mandatory, and you can implement only those you need. The available event methods are defined in 
<a href="https://fisheye.codehaus.org/browse/grails-plugins/grails-weceem/trunk/src/groovy/org/weceem/event/WeceemDomainEvents.groovy?r=HEAD" target="blank">WeceemDomainEvents.groovy</a><p class="paragraph"/>The event methods are:<p class="paragraph"/><div class="code"><pre><span class="java&#45;object">boolean</span> contentShouldBeCreated(WcmContent parentNodeOrNull)</pre></div><p class="paragraph"/>This method allows the content to veto whether or not it can be created. This is called on the newly populated but not saved content node, and is passed the parent node that it would be attached to, which can be null if it is root level content.<p class="paragraph"/><div class="code"><pre>void contentDidGetCreated()</pre></div><p class="paragraph"/>This is called after the content node has been created and saved.<p class="paragraph"/><div class="code"><pre><span class="java&#45;object">boolean</span> contentShouldBeDeleted()</pre></div><p class="paragraph"/>This allows the content type to veto whether or not the node can or should be deleted - e.g. it may not be possible to delete a content node if it has children.<p class="paragraph"/><div class="code"><pre>void contentWillBeDeleted()</pre></div><p class="paragraph"/>This event is triggered just before the node is deleted.<p class="paragraph"/><div class="code"><pre>void contentDidGetDeleted()</pre></div><p class="paragraph"/>This event is triggered immediately after the node is deleted.<p class="paragraph"/><div class="code"><pre>void contentDidChangeTitle(<span class="java&#45;object">String</span> previousTitle)</pre></div><p class="paragraph"/>This event is called when the title property of a node has changed.<p class="paragraph"/><div class="code"><pre>void contentDidGetUpdated()</pre></div><p class="paragraph"/>This event is triggered after a node has been edited and the new values saved.<p class="paragraph"/><div class="code"><pre><span class="java&#45;object">boolean</span> contentShouldMove(WcmContent targetParent)</pre></div><p class="paragraph"/>This event is called to allow it to veto being moved to parent nodes that are not compatible. Returning false will prevent the user moving the node (changing its parent).<p class="paragraph"/><div class="code"><pre>void contentDidMove()</pre></div><p class="paragraph"/>This is called after the content's parent has been changed and saved.<p class="paragraph"/><div class="code"><pre><span class="java&#45;object">boolean</span> contentShouldAcceptChildren()</pre></div><p class="paragraph"/>This event is called to find out if the current node can accept child nodes.<p class="paragraph"/><div class="code"><pre><span class="java&#45;object">boolean</span> contentShouldAcceptChild(WcmContent newChild)</pre></div><p class="paragraph"/>This event is called to find out if the current node can accept the new child node. There might be per-node reasons for vetoing new children.<p class="paragraph"/>You can also hook into many events outside of the domain classes themselves, using the Event Service.<p class="paragraph"/><h4> Customizing the icon shown in the repository</h4><p class="paragraph"/>You can supply an icon for your custom content types, that will be used in the admin UI of Weceem, e.g. in the repository view. To do this, define a static "icon" property which contains the arguments you would pass to <strong class="bold">Grails g:resource tag</strong> to create a link to the resource :<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> icon = &#91;
   plugin: <span class="java&#45;quote">"weceem"</span>,
   dir: <span class="java&#45;quote">"_weceem/images/weceem/content&#45;icons"</span>,
   file: <span class="java&#45;quote">"widget&#45;32.png"</span>
&#93;</pre></div><p class="paragraph"/>It is vital to include the "plugin" attribute and value if you are placing your custom content class in a plugin of your own.<p class="paragraph"/><h4> Content versioning</h4><p class="paragraph"/>In order to participate in Weceem's content versioning system, you need to add any properties you wish to have serialized to the getVersioningProperties() implementation of your class. This function returns a map of values that are stored in the content revision.<p class="paragraph"/>These are simple values that must be expressible as strings. By necessity you may refer to objects not available at the time the user views your revision, so all complex object references that need to be versioned should be coerced to some kind of text representation.<p class="paragraph"/>For a real example, here's the code from WcmHTMLContent :<p class="paragraph"/><div class="code"><pre>Map getVersioningProperties() &#123;
    def r = <span class="java&#45;keyword">super</span>.getVersioningProperties() + &#91;
        menuTitle:menuTitle,
        htmlTitle:htmlTitle,
        keywords:keywords,
        template:template?.ident() // A string representation of template object
    &#93; 
    <span class="java&#45;keyword">return</span> r
&#125;</pre></div><p class="paragraph"/>In almost all cases you will want to call the super method to ensure all inherited properties are correctly versioned.


<h2 id="2.CustomContentEditors">5.3 Custom content editors</h2>
As mentioned in the create custom content type section, you can specify what kind of editor is used for each property of content types. By following some simple procedure, you can also create your own new editors.<p class="paragraph"/>Weceem will locate the appropriate editor using the name of the type of the property, if a custom property editor name is not given.<p class="paragraph"/><h4> Content Editors</h4><p class="paragraph"/>Weceem has quite a few editors that are available to edit all the predefined content type properties.<p class="paragraph"/>| <em class="italic">. Editor Field Name |</em> . Description |
| String | for single-line strings |
| LongString | for multi-line strings |
| Integer | for whole numbers |
| Boolean | for boolean fields |
| Date | for dates, includes datepicker and HH and MM fields |
| Title | uses a larger font for editing the title |
| Tags | UI for displaying and add/remove tags via ajax | 
| ContentFileUpload | renders a file upload field or file information if already uploaded |
| RichHTML | HTML editing with rich editor |
| HTMLContent | HTML content editor that checks allowGSP property on content and switches between RichHTML and HtmlCode as appropriate |
| HtmlCode | Code editor with highlighting for HTML |
| JSCode | Code editor with highlighting for JavaScript |
| GroovyCode | Code editor with highlighting for Groovy code |
|CSSCode | Code editor with highlighting for CSS code |
| LanguageList | a language selection drop-down list |
| WcmScript | For selecting any WcmScript node in the current space |
| WcmStatus | For selecting any WcmStatus instance |
|WcmTemplate | For selecting any WcmTemplate instance in the current space |
| WcmSpace | For selecting a Space |
| ReadOnly | a text-only rendering of the value with no editing capability |
| ReadOnlyURI | a text-only URI value, using URL encoding of restricted chars |
| ReadOnlyDate | a read-only display of a date |<p class="paragraph"/><h4> Writing your own content editor</h4><p class="paragraph"/>Creating a custom editor is simply a case of defining one or two Grails tags in the "wcm" namespace.<p class="paragraph"/>Editors are resolved by looking for a tag with the target editor name appended to "wcm:editorField". So for example a new editor for choosing a colour might be called Colour and the tag would be called "editorFieldColour" :<p class="paragraph"/><div class="code"><pre>class MyWeceemTagLib &#123;
    <span class="java&#45;keyword">static</span> namespace = <span class="java&#45;quote">"wcm"</span><p class="paragraph"/>def editorFieldColour = &#123; attrs &#45;&#62; 
          out &#60;&#60; someFancyColourPicker(pageScope.content&#91;attrs.property&#93;)
    &#125;
&#125;</pre></div><p class="paragraph"/>These tags are called with the following attributes:
<ul class="star">
<li>property - property name of the content object for which the tag should render a field</li>
</ul><p class="paragraph"/>Your tags can access the current content object being edited using :<p class="paragraph"/><div class="code"><pre>pageScope.content&#91;attrs.property&#93;</pre></div><p class="paragraph"/>In the above example,  you would not need to specify editor:'Colour' on your custom content classes if the property type is actually an instance of a Colour class.<p class="paragraph"/><strong class="bold">Note :</strong> Polymorphism is not yet supported in this scenario so only exact class matches will work.<p class="paragraph"/><h4> Providing resources needed by custom editors</h4><p class="paragraph"/>Some editors - e.g. the FCK and code editors used by Weceem, require JavaScript and CSS resources to be included in the &#60;head&#62; section of the editor page. To achieve this, Weceem looks for a tag with a name like "wcm:editorResourcesColour" where the type name is appended to "editorResources". This tag can output anything you like into the &#60;head&#62; section of the page:<p class="paragraph"/><div class="code"><pre>def editorResourcesTags = &#123; attrs &#45;&#62;
        out &#60;&#60; g.render(template:'/editors/tags_resources', plugin:'weceem', 
            model:&#91;name:attrs.property, value:pageScope.content&#91;attrs.property&#93;&#93;)
    &#125;</pre></div><p class="paragraph"/>Here, the Tags editor uses another GSP to output the more complex resource elements it requires, setting up JS code in the &#60;head&#62; section to bind add/remove buttons using jQuery.<p class="paragraph"/>


<h2 id="3.CustomRequestAndFormSubmissionWithGroovyScripts">5.4 Custom request/form submission with groovy scripts</h2>
Capture data from forms and perform an action, such as sending mail after submission of a contact form by writing some Groovy code that you store in the content repository. This happens dynamically and you don't need to redeploy your Weceem application or restart it.<p class="paragraph"/>Two content types work together in Weceem to enable you to write arbitrary server-side code. The Scripted Action node type is used to receive requests, and delegates the work to a Groovy Script node.<p class="paragraph"/>For example, to create a Contact form that sends mail to a known address, you could implement it like this :
<ol>
<li>Create a Groovy Script node in your repository, and paste into it the following code :</li>
</ol><p class="paragraph"/><div class="code"><pre>def args = &#91;
  recipients:'admin@yourserver.com',
  subject:'Message from website visitor'
&#93;
<span class="java&#45;keyword">try</span> &#123;
  sendMail &#123;
    to args.recipients
    <span class="java&#45;keyword">if</span> (args.ccRecipients) &#123;
      cc args.ccRecipients
    &#125;
    subject args.subject<p class="paragraph"/>    from params.senderAddress
    body params.message
  &#125;
  redirect(uri:params.success)
&#125; <span class="java&#45;keyword">catch</span> (Exception e) &#123;
  log.error <span class="java&#45;quote">"Can't send mail"</span>, e
  redirect(uri:params.error)
&#125;</pre></div><p class="paragraph"/>This code expects the Grails "mail" plugin to be installed (as it is by default in the Weceem application WAR file). This code is exactly what you would write if you were writing your own <a href="https://grails.org/doc/latest/guide/theWebLayer.html#6.1%20Controllers." target="blank">Grails controller action</a>  You can call redirect, render and other Grails controller methods as usual. The request parameters are in "params".<p class="paragraph"/><a href="https://grails.org/doc/latest/guide/theWebLayer.html#6.1%20Controllers" target="blank">WeceemDomainEvents.groovy</a><p class="paragraph"/>2. Now that you have a script to run, you need to create a Scripted Action node to respond to requests for a specific URI and run the script. When you do this, select the script you created in the "Script" field. The full repository URI of this Scripted Action content node is the URI that needs to be used in your HTML form's action attribute. You can create links to this action inside your own Widget or Template nodes using the wcm:createLink tag.<p class="paragraph"/>With the above example, the HTML form needs to supply fields "senderAddress" and "message". It will redirect the user to the value of the "success" parameter which will usually be a URI in your content repository created using the wcm:createLink tag.<p class="paragraph"/>You can write any Groovy code you like in the Groovy Script node. The possibilities are endless for example, you can call out to external web services, perform calculations, render complex results in alternative formats (e.g. JSON).<p class="paragraph"/>However, you can easily degrade the performance of your server by writing inefficient code in a Groovy Script that is executed frequently.<p class="paragraph"/>It is strongly recommended that you limit the users that can create Groovy Scripts using the Weceem Security Policy.


<h2 id="4.EmbeddingContent">5.5 Embedding content</h2>
In some custom applications you may want to embed some Weceem content within your own Grails GSP views. This is easily achieved for most situations using the new <strong class="bold">wcm:render</strong> tag as of release 1.1.<p class="paragraph"/>However, if you need to render content with more control over the process - e.g. using an artificial request/response to render content for use in emails, you can use the wcmRenderEngine bean.<p class="paragraph"/>This bean offers methods for rendering a specific content node.<p class="paragraph"/>You must typically pass in a request and response to use - given that most of Weceem functionality uses Grails tags and these require features of requests and responses - although you can usually also pass in your own controller instance if you have one.<p class="paragraph"/>See the source code for <a href="https://github.com/jCatalog/weceem-plugin/blob/master/src/groovy/org/weceem/content/RenderEngine.groovy" target="blank">RenderEngine on github</a> for more details.


<h2 id="5.ExportingAndImportingContent">5.6 Exporting and importing content</h2>
Each Weceem space (repository) can be individually exported and imported individually and is useful for backups or migrating content between servers or spaces.<p class="paragraph"/>For this :
<ol>
<li>Go to the Administration section</li>
<li>Select option - "Spaces"</li>
<li>Click  the Export or Import buttons</li>
<li>Select space when prompted.</li>
</ol><p class="paragraph"/>Use the default import/exporter - it is the native Weceem exporter.<p class="paragraph"/>The exported ZIP file will include all content nodes and uploaded files for that space. You can then import this ZIP into another Weceem instance, or to a different space in the same instance.<p class="paragraph"/><strong class="bold">Importing will replace any content in the space!</strong><p class="paragraph"/><strong class="bold">Note :</strong><p class="paragraph"/>Exported spaces will not include your user accounts or any custom WcmStatus nodes you created, as these are not Space-specific.



<h2 id="6.HookingIntoContentEvents">5.7 Hooking into content events</h2>
In custom Grails applications that use Weceem plugin you may need to perform actions when certain events occur on content.<p class="paragraph"/>To do this, register a listener with the WcmEventService and implement any of the event notification methods you require.<p class="paragraph"/>First, you inject the WcmEventService using Grails dependency injection, or obtain it via the Spring ApplicationContext, and then call the "addListener" method :<p class="paragraph"/><div class="code"><pre>class MyService <span class="java&#45;keyword">implements</span> InitializingBean &#123;
    def wcmEventService<p class="paragraph"/>    void afterPropertiesSet() &#123;
        wcmEventService.addListener(<span class="java&#45;keyword">this</span>)
    &#125;<p class="paragraph"/>    void contentDidGetUpdated(WcmContent node) &#123;
        log.info <span class="java&#45;quote">"Look! Content $&#123;node.title&#125; was updated"</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>The list of available events is defined in the WeceemEvents class, which uses an optional event callback method mechanism -<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> org.weceem.event<p class="paragraph"/><span class="java&#45;keyword">import</span> org.weceem.content.WcmContent<p class="paragraph"/>class WeceemEvents &#123;
    <span class="java&#45;keyword">static</span> events = &#123;
        /&#42; Called just before saving the node &#42;/
        contentWillBeCreated &#123; WcmContent contentNode, WcmContent parentNode &#45;&#62; &#125;
        /&#42; Called after a <span class="java&#45;keyword">new</span> node has been created &#42;/
        contentDidGetCreated &#123; WcmContent node &#45;&#62; &#125;<p class="paragraph"/>        /&#42; Called before a node is deleted &#42;/
        contentWillBeDeleted &#123; WcmContent node &#45;&#62; &#125;
        /&#42; Called after a node is deleted &#42;/
        contentDidGetDeleted &#123; WcmContent node &#45;&#62; &#125;<p class="paragraph"/>        /&#42; Called after a <span class="java&#45;keyword">new</span> node is updated &#42;/
        contentDidGetUpdated &#123; WcmContent node &#45;&#62; &#125;<p class="paragraph"/>        /&#42; Called after a <span class="java&#45;keyword">new</span> node is moved to a <span class="java&#45;keyword">new</span> parent &#42;/
        contentDidMove &#123; WcmContent node, <span class="java&#45;object">String</span> previousURL, WcmContent previousParent &#45;&#62; &#125;
    &#125;<p class="paragraph"/>    <span class="java&#45;keyword">static</span> &#123;
        EventManager.define(WeceemEvents)
    &#125;
&#125;</pre></div><p class="paragraph"/>Implement the methods you need, using the signature defined in the WeceemEvents class.<p class="paragraph"/>There is a separate event interface called WeceemDomainEvents (given below) for developers that supply custom content types and for this you do not need to register as a lister - they are called as part of the regular lifecycle.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> org.weceem.event<p class="paragraph"/><span class="java&#45;keyword">import</span> org.weceem.content.WcmContent<p class="paragraph"/>class WeceemDomainEvents &#123;
    <span class="java&#45;keyword">static</span> events = &#123;
        /&#42; Called before a <span class="java&#45;keyword">new</span> node is created. Return <span class="java&#45;keyword">true</span> to allow the creation &#42;/
        contentShouldBeCreated &#123; WcmContent parentConent &#45;&#62; &#125;
        /&#42; Called just before saving the node &#42;/
        contentWillBeCreated &#123; WcmContent parentConent &#45;&#62; &#125;
        /&#42; Called after a node has been created, so that it can intialize anything that depends on it &#42;/
        contentDidGetCreated()<p class="paragraph"/>
        /&#42; Called to see <span class="java&#45;keyword">if</span> a node can be deleted. Return <span class="java&#45;keyword">true</span> to permit the deletion &#42;/
        contentShouldBeDeleted()
        /&#42; Called before a node is deleted. &#42;/
        contentWillBeDeleted()
        /&#42; Called after a node is deleted. &#42;/
        contentDidGetDeleted()<p class="paragraph"/>        /&#42; Called after a node's title has changed (edited). &#42;/
        contentDidChangeTitle &#123; <span class="java&#45;object">String</span> previousTitle &#45;&#62; &#125;
        /&#42; Called after a node is updated (edited). &#42;/
        contentDidGetUpdated()<p class="paragraph"/>        /&#42; Called before a node is moved to a <span class="java&#45;keyword">new</span> parent. Return <span class="java&#45;keyword">true</span> to permit the move. Parent may be <span class="java&#45;keyword">null</span> &#42;/
        contentShouldMove &#123; WcmContent newParent &#45;&#62; &#125;
        /&#42; Called after a node is moved to a <span class="java&#45;keyword">new</span> parent. &#42;/
        contentDidMove &#123; <span class="java&#45;object">String</span> previousURL, WcmContent previousParent &#45;&#62; &#125;<p class="paragraph"/>        /&#42; Called to establish whether <span class="java&#45;keyword">this</span> node can have children. Return <span class="java&#45;keyword">true</span> to permit addition of children &#42;/
        contentShouldAcceptChildren()
        /&#42; Called before a node is moved to become a child of <span class="java&#45;keyword">this</span> node. Return <span class="java&#45;keyword">true</span> to permit addition of the <span class="java&#45;keyword">new</span> child &#42;/
        contentShouldAcceptChild &#123; WcmContent possibleChild &#45;&#62; &#125;
    &#125;<p class="paragraph"/>    <span class="java&#45;keyword">static</span> &#123;
        EventManager.define(WeceemDomainEvents)
    &#125;
&#125;</pre></div>


<h2 id="7.PageRendering">5.8 Page rendering</h2>
When a request is made to Weceem, it goes through a number of steps to produce the final content.
<ol>
<li> Weceem first locates the content at the URI path specified in the request</li>
<li> Once located, it checks if content can be rendered. Content which is not "standalone" and used by other content cannot be rendered directly (e.g. Templates cannot be rendered directly).</li>
<li> Next, it checks to see if the content implements rendering itself. If it does, it will call the content's handleRequest method to perform the rendering of the response.</li>
<li> If there is no handleRequest method, Weceem will look for a "template" property on the content object and if it finds one, will ask that template to render the content.</li>
</ol><p class="paragraph"/>Different content types may implement handleRequest differently - e.g. HTML Content first checks if the content is set to allow GSP tags to execute. If they are, it will execute the page and capture the output. The content is then passed to the template (if any) and returned to the client.<p class="paragraph"/><strong class="bold">Note :</strong> If the content supports templates and a template is not set,  Weceem will look up the content tree to see if any ancestors specify a template and will use the first one it finds.<p class="paragraph"/>In this most common case, the HTML and Template will work together and render one or more Widget nodes using &#60;wcm:widget&#62; to render common page elements like the header and footer sections.<p class="paragraph"/>Other types such as External Link will use handleRequest to issue a redirect to the browser.<p class="paragraph"/><h4> Default document handling</h4><p class="paragraph"/>Weceem supports httpd-style request URLs that end in /,  it will automatically check for a child node of the URI, with one of the default names ("index.html" or "index"), much like a regular webserver.


<h2 id="8.IntegratingTheAuthenticationAndAuthorisationSystem">5.9 Integrating the  authenticationand authorisation system</h2>
The Weceem plugin neither provides an authentication mechanism nor depends on authentication plugins. Just wire-in whichever authentication system you want to use - e.g.  the Weceem CMS Application wires up the Weceem plugin to the Spring Security plugin for authentication and provides a simple user management UI as part of the Weceem Admin.
Customizing Authentication<p class="paragraph"/>The WcmSecurityService class has simple methods on it that the CMS uses to get information about the current logged-in user. To customize this, just replace or modify the delegate property on the service - e.g. to plug in Acegi (note that Spring Security replaces Acegi - see below for an off the shelf solution), you would place code like this in the BootStrap of your application :<p class="paragraph"/><div class="code"><pre>def authenticateService = context.authenticateService<p class="paragraph"/>context.wcmSecurityService.securityDelegate = &#91;
	getUserName : &#123; &#45;&#62;
		def princ = authenticateService.principal()
		<span class="java&#45;keyword">if</span> (princ <span class="java&#45;keyword">instanceof</span> <span class="java&#45;object">String</span>) &#123;
			<span class="java&#45;keyword">return</span> <span class="java&#45;keyword">null</span>
		&#125; <span class="java&#45;keyword">else</span> &#123;
			<span class="java&#45;keyword">return</span> authenticateService.principal()?.username
		&#125;
	&#125;,
	getUserEmail : &#123; &#45;&#62;
		def princ = authenticateService.principal()
		<span class="java&#45;keyword">if</span> (princ <span class="java&#45;keyword">instanceof</span> <span class="java&#45;object">String</span>) &#123;
			<span class="java&#45;keyword">return</span> <span class="java&#45;keyword">null</span>
		&#125; <span class="java&#45;keyword">else</span> &#123;
			<span class="java&#45;keyword">return</span> authenticateService.principal()?.email
		&#125;
	&#125;
        getUserRoles : &#123; &#45;&#62; 
		authenticateService.userDomain()?.roleAuthorities ?: &#91;'ROLE_GUEST'&#93; 
	&#125;,
        getUserPrincipal : &#123; &#45;&#62; 
		authenticateService.principal()
	&#125;
&#93;</pre></div><p class="paragraph"/><h4> Integration with Spring Security</h4><p class="paragraph"/>If you create your own application using Weceem plugin and wish to use the Grails Spring Security plugin, install the weceem-spring-security plugin to provide the bridge between Weceem and your application's Spring Security authentication/authorization scheme.<p class="paragraph"/>When you use this plugin there is no need to write your own UserDetailsService for the Spring Security plugin.<p class="paragraph"/>To do this, after installing the plugin you simply have to specify some configuration to tell the plugin how to map from your Spring Security domain classes, and the plugin will make this information available to Weceem :<p class="paragraph"/><div class="code"><pre>weceem.springsecurity.details.mapper = &#123; &#45;&#62;
    &#91; // Stuff required by weceem spring sec
        username: username,
        password: password,
        enabled: enabled,
        authorities: authorities,
        // optional stuff we add
        email: email,
        description: description,
        firstName: firstName,
        lastName: lastName,
        id: id
    &#93;
&#125;</pre></div><p class="paragraph"/>This closure must return a map of data used by Spring Security to store the information about your domain class. The "it" passed to the closure is the domain class instance, so the above is returning a map with values copied from the domain class.<p class="paragraph"/><strong class="bold">Note :</strong> Only information required by Weceem is the username, password, enabled and authorities. Everything else is optional and only used by your application if you code it to do so.<p class="paragraph"/>The application remains responsible for defining the domain classes and performing the relevant Spring Security configuration to protect your URIs.<p class="paragraph"/>


<h2 id="9.StylingWithTemplates">5.10 Styling With Templates</h2>
Templates are content nodes used to set page layouts on your site. Certain content types such as HTML and Blog, support setting a template when creating or editing nodes. If a template is not set, it is inherited from the content's ancestors.<p class="paragraph"/>Typically the template will include the head and body tags, pull in the CSS and other resources required, and provide some common layout elements.<p class="paragraph"/>They use standard Grails tags and Weceem tags to render content within the body of the page, as well as meta data about the current page e.g. dynamic titles.<p class="paragraph"/>Here's a simple example that renders a dynamic title and renders the content of the current node.<p class="paragraph"/><div class="code"><pre>&#60;html&#62;
  &#60;head&#62;
    &#60;title&#62;$&#123;page.title.encodeAsHTML()&#125;&#60;/title&#62;
  &#60;/head&#62;
  &#60;body&#62;
    &#60;div id=<span class="java&#45;quote">"content"</span>&#62;
      &#60;wcm:content/&#62;
    &#60;/div&#62;
  &#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>The <code>&#60;wcm:content/&#62;</code> tag is used to render the content of the page the user requested. Its important to remember that your Template is not actually requested by the user by URI - it is simply used to decorate the content the user requested.<p class="paragraph"/>You might add a news panel to this layout, by using the <code>&#60;wcm:widget&#62;</code> tag to render a reusable block that iterates over children of the "News" node to list the titles of articles and links to them.<p class="paragraph"/><p class="paragraph"/>

                    </div>
                </td>
                <td id="col2">
            <div class="local clearfix">
                <div class="local-title">
                    <a href="../guide/index.html" target="mainFrame">Quick Reference</a>
                    <span class="toggle">(<a href="#" onclick="localToggle(); return false;">hide</a>)</span>
                </div>
                <div class="menu">
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">Domain</h1><div class="menu-sub">
                        
                        
                        <div class="menu-item"><a href="../ref/Domain/attach.html">attach</a>
                        </div>
                        
                        </div>
                    </div>
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">Tags</h1><div class="menu-sub">
                        
                        
                        <div class="menu-item"><a href="../ref/Tags/ancestorOfType.html">ancestorOfType</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/archiveList.html">archiveList</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/breadcrumb.html">breadcrumb</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/cache.html">cache</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/content.html">content</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/contentIconURL.html">contentIconURL</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/countChildren.html">countChildren</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/createFeedLink.html">createFeedLink</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/createLink.html">createLink</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/createSearchLink.html">createSearchLink</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/dataFeed.html">dataFeed</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/date.html">date</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/eachChild.html">eachChild</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/eachComment.html">eachComment</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/eachContent.html">eachContent</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/eachParent.html">eachParent</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/eachSibling.html">eachSibling</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/feedLink.html">feedLink</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/find.html">find</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/findNode.html">findNode</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/htmlToText.html">htmlToText</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/ifContentIs.html">ifContentIs</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/ifContentIsNot.html">ifContentIsNot</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/ifUserCanEdit.html">ifUserCanEdit</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/ifUserCanView.html">ifUserCanView</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/join.html">join</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/link.html">link</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/loggedInEmail.html">loggedInEmail</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/loggedInUserName.html">loggedInUserName</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/menu.html">menu</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/monthNames.html">monthNames</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/render.html">render</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/renderContentItemIcon.html">renderContentItemIcon</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/resource.html">resource</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/search.html">search</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/searchLink.html">searchLink</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/space.html">space</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/submitContentForm.html">submitContentForm</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/submitContentLink.html">submitContentLink</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/summarize.html">summarize</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/uiMessage.html">uiMessage</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/userInfo.html">userInfo</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Tags/widget.html">widget</a>
                        </div>
                        
                        </div>
                    </div>
                    
                </div>
            </div>
        </td>
            </tr>
        </table>

        <div id="footer">
            
            
        </div>



<script type="text/javascript" src="../js/docs.js"></script>

    </body>
</html>
